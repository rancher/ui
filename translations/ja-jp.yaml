---
languageName: "日本語"
languageContribute: "Rancher の翻訳にご協力ください"
generic:
  actions: アクション
  activate: アクティベート
  add: 追加
  advanced: 詳細
  all: 全て
  any: Any
  application: アプリケーション
  as: として
  back: 戻る
  cancel: キャンセル
  closeModal: 閉じる
  cluster: クラスター
  collapseAll: すべて折りたたむ
  comingSoon: Coming Soon
  command: コマンド
  confirm: 確認
  containers: コンテナ
  created: 作成日
  createdDate: "{date} 作成"
  custom: カスタム
  customize: 設定変更
  default: デフォルト
  description: 詳細情報
  details: 詳細
  disable: 無効
  disabled: 無効
  displayName: 表示名
  dockerId: Docker ID
  domainName: ドメイン名
  done: 完了
  download: ダウンロード
  edit: 編集
  enable: 有効
  enabled: 有効
  entrypoint: エントリーポイント
  environment: 環境
  expandAll: すべて開く
  from: from
  generic: '一般'
  gigabyte: 'GB'
  hardware: ハードウェア
  healthy: ヘルス
  help: ヘルプ
  hostname: ホスト名
  hours: 時間
  id: ID
  image: イメージ
  import: インポート
  internal: 内部
  ipAddress: IP アドレス
  key: キー
  limit: 制限
  limits: 制限
  loading: "読込中..."
  loggingOut: "ログアウト中…"
  member: メンバー
  mbps: Mbps
  mibibyte: 'MiB'
  minutes: 分
  milliseconds: 'ミリ秒'
  missing: "*%MISSING%*"
  moreActions: その他の操作
  na: 'n/a'
  name: 名前
  namespace: 名前空間
  namespaces: 名前空間
  never: しない
  no: "いいえ"
  noRating: 評価なし
  node: ノード
  none: None
  owner: 所有者
  paste: ペースト
  pod: pod
  port: ポート
  ports: ポート
  prefix: 接頭辞
  project: プロジェクト
  persistentVolume: 永続ボリューム
  random: ランダム
  remove: 削除
  restarts: 再起動
  role: ロール
  save: 保存
  saved: 保存済み
  saving: 保存中
  scope: スコープ
  search: 検索
  searchOrCustomInput: カスタム値を検索または入力してください。
  searching: '検索中...'
  seconds: 秒
  select: 選択
  service: サービス
  services: サービス
  size: サイズ
  state: 状態
  tags: タグ
  test: テスト
  testing: テスト中
  to: に
  total: 合計
  type: タイプ
  unknown: 不明
  unknownUser: ユーザー情報を取得できません
  upload: アップロード
  url: URL
  user: ユーザー
  uuid: UUID
  value: 値
  version: バージョン
  yes: "はい"
realmNames:
  all: 全て
  usWest: US 西部
  usEast: US 東部
  asia: アジア
  euWest: EU 西部
  euEast: EU 東部
accountsPage:
  detail:
    header: ユーザーの詳細
    table:
      headers:
        permission: 権限
        role: ロール
        clusterName: クラスター
        projectName: プロジェクト
        active: アクティブ
        created: 付与日
      global:
        title: グローバル権限
        description: インストール全体に影響を与えるものを管理するためのアクセス権
        admin: このユーザーは管理者であり、すべての権限を持っています。
        noRoles: このユーザーにはグローバルロールはありません
      cluster:
        title: クラスターロール
        description: 個々のクラスタに対してこのユーザーに付与されるロール
        noRoles: このユーザーにはクラスタロールはありません
      project:
        title: プロジェクトロール
        description: 個々のプロジェクトに対してこのユーザーに付与されるロール
        noRoles: このユーザーにはプロジェクトロールはありません
      roles:
        title: ロール
  index:
    header: ユーザー
    localLink: ユーザーを追加
    table:
      id: ID
      kind: 種類
      username: ローカルユーザー名
      identity: ID
      noData: まだユーザーはありません
      noMatch: 検索条件に一致するユーザーはいません
      noName: None
  new:
    header: ユーザーを追加
    errors:
      usernameReq: ユーザー名が必要です
      usernameInExists: ログインユーザー名は既に利用されています。他のユーザー名を選択してください。
      pwReq: パスワードが必要です
      role: 新規ユーザーはロールに所属する必要があります。リストからロールを選択してください。
    form:
      username:
        labelText: ユーザー名
        placeholder: "例: jsmith"
      password:
        labelText: パスワード
      name:
        labelText: 表示名
        placeholder: "例: ジョン ・ スミス"
      type:
        labelText: アカウントタイプ
      description:
        labelText: 詳細情報
        placeholder: "例: このアカウントは、ジョン ・ スミス用"
  modal:
    password: パスワードを変更
appDetailPage:
  header: "アプリケーション: {appName}"
  endpoints:
    title: エンドポイント
    detail: 'このアプリケーションの公開エンドポイント'
    endpoint: エンドポイント
    protocol: プロトコル
    noData: このアプリケーションには公開エンドポイントは作成されていません
    noMatch: 検索条件に一致する公開エンドポイントはありません
  answers:
    variable: 変数
  notes:
    title: Notes
    detail: 'このアプリケーションを利用するための手順です'
  workloads:
    title: ワークロード
    detail: このアプリケーションに作られたワークロードです
    nodata: このアプリケーションにワークロードは作成されていません
  ingress:
    title: イングレスルール
    detail: このアプリケーションに作られたイングレスルールです
    nodata: このアプリケーションにイングレスルールは作成されていません
  services:
    title: サービス
    detail: このアプリケーションに作成されたサービスです
    nodata: このアプリケーションにサービスは作成されていません
  volumes:
    title: ボリューム
    detail: このアプリケーションに作られた永続ボリューム要求です
    nodata: このアプリケーションにボリューム要求は作成されていません
  configMaps:
    title: コンフィグマップ
    detail: このアプリケーションに割りあてられているコンフィグマップです
    nodata: このアプリケーションにコンフィグマップは作成されていません
  secrets:
    title: シークレット
    detail: このアプリケーションに割り当てられているシークレットです
    nodata: このアプリケーションにシークレットは作成されていません
podSecurityPoliciesPage:
  index:
    header: ポッドセキュリティポリシー
    description: このロールを持つユーザーが作成したポッドにポリシーを適用する
    table:
      name: 名前
      created: 作成日
      noData: まだポッドセキュリティポリシーは定義されていません
      noMatch: 検索条件に一致するポッドセキュリティポリシーがありません
  addPodSecurityPolicy: ポリシーを追加
  editPodSecurityPolicy: ポリシーを編集
  detail:
    header: ポリシー
  saveEdit: 編集
  saveNew: 作成
  new:
    errors:
      nameReq: 名前が必要です
      nameInExists: 名前は既に存在します。新しいポッドセキュリティポリシー名を使用してください。
    form:
      name:
        labelText: 名前
        placeholder: "例: policy"
rolesPage:
  title: ロール
  headers:
    global: グローバル
    cluster: クラスター
    project: プロジェクト
  index:
    localLink: ロールを追加
    table:
      builtin: ビルトイン
      created: 作成時刻
      enabled: 有効
      name: 名前
      noData: まだロールはありません
      noMatch: 検索条件に一致するロールがありません
      subjectKind: 種類
      template: テンプレート
      showDefaults: デフォルトのみを表示
  inherit:
    title: ロールから継承
    detail: 他のロールからの全ての権限を含む
  addRole: "{context} ロールを追加"
  editRole: ロールの編集
  saveEdit: 編集
  saveNew: 作成
  new:
    errors:
      nameReq: 名前が必要です
      memberReq: メンバーが必要です
      nameInExists: 名前は既に存在します。新しいロール名を使用してください。
      ruleResourceReq: ルールにはリソースが必要です。
      roleTemplate: ロールテンプレートが必要です
    form:
      name:
        labelText: 名前
        placeholder: "例: Developers"
      context:
        labelText: コンテキスト
      locked:
        labelText: ロック済み
        disabled: "いいえ"
      allow:
        create: 作成
        delete: 削除
        deletecollection: 'コレクションを削除'
        get: 取得
        list: リスト
        patch: パッチ
        update: 更新
        watch: 監視
        labelText: 許可
        resource: リソース
        addAction: リソースを追加
      otherRole:
        labelText: 他の役割を含める
        role: ロール
        addAction: ロールを追加
      policy:
        policy: ポリシー
        addAction: ポリシーを追加
      default:
        disabled: "いいえ"
apiPage:
  header: API & キー
  actionButton: キーを追加
  currentEndpoint: 'エンドポイント:'
  detail: API キーは特定のユーザー({name}) に紐付けられ、アクセス可能な全てのクラスターやプロジェクトに対しての作成、削除、操作が可能です
  table:
    state: 状態
    name: アクセスキー
    description: 詳細情報
    scope: スコープ
    created: 作成日
    expires:
      label: 失効日
      never: 失効しない
    noData: まだ API キーは定義されていません
authPage:
  saml:
    accessEnabled:
      header: 認証
      disable: アクセスコントロールを無効化
    header:
      disabled:
        label: "{providerName} が設定されていません"
    enabled:
      authenticated:
        header:
          text: 認証
      groupsField: 'グループ:'
      displayName: '表示名:'
      userName: 'ユーザー名:'
      userId: 'ユーザー ID:'
    disabled:
      name:
        labelText: 表示名フィールド
        display: "表示名フィールド:"
      username:
        labelText: ユーザー名フィールド
        display: "ユーザー名フィールド:"
      uid:
        labelText: UID フィールド
        display: "UID フィールド:"
      rancherApiHost:
        labelText: "{appName} APIホスト"
        display: "{appName} APIホスト:"
      groups:
        labelText: グループ フィールド
        display: "グループ フィールド:"
      testAuth:
        header: '2. 認証をテストして有効化する'
        subtext: '認証テストを行うことであなたのアプリケーションが正常に設定されたことを確認します:'
    providerName:
      ping: Ping
      adfs: AD FS
      keycloak: Keycloak
      okta: Okta
  ping:
    buttonText:
      pre: 'Pingによる認証'
      post: IDP からの返答を待っています
  keycloak:
    buttonText:
      pre: 'Keycloackによる認証'
      post: IDP からの返答を待っています
  adfs:
    buttonText:
      pre: 'AD FSによる認証'
      post: IDP からの返答を待っています
  shibboleth:
    enabled:
      authenticated:
        header:
          text: 認証
      disableAccess:
        header: "Danger Zone&trade;"
        warning: '<b class="text-danger">注意:</b> アクセスコントロールを無効化すると、このページや API にアクセスできる全ての人が {appName} 経由でフルコントロールするこ>とができます。'
        disable: アクセスコントロールを無効化
      groupsField: 'グループ:'
      displayName: '表示名:'
      userName: 'ユーザー名:'
      userId: 'ユーザー ID:'
    disabled:
      header: '1. シボレスアカウントを設定する'
      label: "{providerName} が設定されていません"
      name:
        labelText: 表示名フィールド
      username:
        labelText: ユーザー名フィールド
      uid:
        labelText: UID フィールド
      groups:
        labelText: グループ フィールド
      testAuth:
        header: '2. テストのうえ認証を有効化する'
        subtext: '認証テストを行うことであなたのアプリケーションが正常に設定されたことを確認します:'
        buttonText:
          pre: IDPによる認証
          post: IDP からの返答を待っています
    providerName:
      shibboleth: シボレス
  root:
    header: アクセスコントロール
  github:
    standard: GitHub
    enterprise: GitHub エンタープライズ
    header:
      disabled:
        label: GitHub が設定されていません
    authenticated:
      header:
        text: 認証
        enterpriseHostName: "エンタープライズホスト:"
        clientId:
          text: "クライアント ID:"
          helpText: "設定済み GitHub アプリケーションを変更するには以下のアクセスコントロールを無効化し、再度設定し直して下さい。"
      disableAccess:
        header: "Danger Zone&trade;"
        warning: '<b class="text-danger">注意:</b> アクセスコントロールを無効化すると、このページや API にアクセスできる全ての人が {appName} 経由でフルコントロールすることができます。'
        disable: Github アクセスを無効化
    notAuthenticated:
      header: "1. GithHub アプリケーションをセットアップする"
      ul:
        li1:
          text: '通常の GitHub の場合、新規ウィンドウでアプリケーション設定を行うために <a href="https://github.com/settings/developers" target="_blank">こちらをクリック</a> してください。'
          ul:
            li1: "GitHub エンタープライズの場合、あなたのアカウントでログインし Settings、Applications の順にクリックしてください。"
        li2:
          text: '"新規アプリケーションの登録" をクリックし、必要事項を入力してください:'
          ul:
            li1: '<b>アプリケーション名:</b> <span class="text-muted">自由記載, e.g. My {appName}</span>'
            li2: 'ホームページ URL'
            li3: '<b>アプリケーションの詳細情報:</b> <span class="text-muted">自由記載(オプション)</span>'
            li4: '認証コールバック URL'
        li3:
          text: '"アプリケーションを登録" をクリック'
      form:
        header: '2. 認証にあなたのアプリケーションを利用するよう {appName} を設定'
        subtext: '新しく作成したアプリケーションの右上からクライアント ID と秘密キーをコピー&ペーストします。'
        clientId:
          labelText: クライアント ID
        clientSecret:
          labelText: クライアント秘密キー
        ghEnterprise:
          labelText: プライベートの GitHub エンタープライズを使う
        isGHEnterprise:
          labelText: セキュア接続を使う
        enterpriseHost:
          labelText: エンタープライズホスト
          placeholder: '例: github.example.com'
    testAuth:
      header: '3. テストのうえ認証を有効化する'
      subtext: '認証テストを行うことであなたのアプリケーションが正常に設定されたことを確認します:'
      buttonText:
        pre: GitHubアカウントで認証
        post: GitHub からの返答を待っています
  azuread:
    header:
      disabled:
        label: "Azure ADは設定されていません"
    enabled:
      header: 'Danger Zone&trade;'
      promptDisable: アクセスコントロールを無効化
      general:
        header: 一般
    configure:
      header: '1. Azure AD アカウントを設定する'
      applicationId:
        label: アプリケーション ID
      applicationSecret:
        label: アプリケーションパスワード
      serverURL:
        label: Rancher サーバー URL
      azureADEndpoint:
        label: エンドポイント
      azureADGraphEndpoint:
        label: グラフエンドポイント
      azureADTokenEndpoint:
        label: トークンエンドポイント
      azureADAuthEndpoint:
        label: 認証エンドポイント
      endpoints:
        label: エンドポイント
      regions:
        standard: スタンダード
        china: 中国
        custom: カスタム
      tenantId:
        label: テナント ID
        placeholder: A long UUID string
        help: Azure AD ポータルから取得
    test:
      header: '2. テストのうえ認証を有効化する'
      help: 'あなたのアカウントで認証テストを行うことで全てが正常に設定されたことを確認します:'
      username:
        label: ログイン ユーザー名
        placeholder: '例: jsmith'
      password:
        label: ログイン パスワード
      pre: Azure で認証
      post: Azure からの返答を待っています
      popupError: 'ポップアップブロッカーを停止して、もう一度 "認証" をクリックしてください。'
  localAuth:
    header:
      enabled: 'ローカル認証が 有効 です'
      disabled: 'ローカル認証は設定されていません'
    subtext:
      enabled:
        text: '{appName} はローカルデータベースを利用したアクセス許可が設定されています。'
        alwaysOn: 'ローカル認証は常に有効化されていますが追加で他の認証方法を選択することができます'
        linkText: アカウントを管理
      disabled: '{appName} は {appName} データベースで定義されたいくつかのアカウントに対してアクセスを制限するよう設定できます。現在はこの設定がされていないため、このページ(または API)にアクセスできる全ての人がシステムを介してフルコントロールすることができます。'
    accessEnabled:
      header: 'Danger Zone&trade;'
      warning: '<b class="text-danger">注意:</b> アクセスコントロールを無効化すると、このページや API にアクセスできる全ての人が {appName} 経由でフルコントロールすることができます。'
      buttonText:
        prompt: アクセスコントロールを無効化
    accessDisabled:
      header: '1. 管理者ユーザーをセットアップする'
      helpText: 'このユーザーは {appName} 上でのフルコントロール権限を持つ管理者になります。'
      form:
        login:
          labelText: ログイン ユーザー名
          placeholder: '例: jsmith'
        name:
          labelText: 姓名
          placeholder: '例: ジョン スミス'
        password:
          labelText: パスワード
        confirmPassword:
          labelText: パスワード(確認用)
    accessControl:
      header: '2. アクセスコントロールを有効化する'
      helpText: 'ローカル認証を有効化をクリックしてログインします。'
      buttonText:
        pre: ローカル認証を有効化
        post: '有効化中...'
backupsPage:
  header: etcdスナップショット
  table:
    target:
      s3: S3
      local: ローカル
    name: 名前
balancerPage:
  noMatch: 検索条件に一致するバランサーがありません
  noData: 表示するバランサーはありません
  table:
    target: 対象
catalogPage:
  index:
    header: カタログ
    refreshBtn: 再読み込み
    allCatalogs: 全てのカタログ
    allCategories: 全てのカテゴリ
    manage: 管理
    search:
      label: 検索
    filters:
      label: カタログフィルター
    certified:
      rancher:
        rancher: Rancher Labs
        partner: 公式
      pl:
        rancher: コア
        partner: 公式
    noData:
      singular: 互換性のあるテンプレートがありません
      plural: このカタログには互換性のあるテンプレートがありません
    action:
      launch: 詳細を見る
      notCompatible: 互換性がありません
      alreadyDeployed: 既にデプロイ済みです
certificatesPage:
  cn: ドメイン名
  expiresDate: 有効期限
  fingerprint: フィンガー プリント
  valid: 有効な発行日
  expires: 有効期限
  algorithm: アルゴリズム
  issuer: 報告者
  serialNumber: シリアルナンバー
  domainNames:
    labelText: ドメイン名
    single: '<a href="https://{cn}" target="_blank" rel="nofollow nefererrer noopener">{cn}<i class="icon icon-sm icon-external-link"/></a>'
    withSan: |
      <a href="https://{cn}" target="_blank" rel="nofollow nefererrer noopener">{cn} <i class="icon icon-sm icon-external-link"/></a> +
      {sans, plural,
      other {# others}
      }
    wildcardSingle: '{cn}'
    wildcardWithSan: |
      {cn} +
      {sans, plural,
      other {# others}
      }
  detail:
    header: '証明書: {name}'
  index:
    header: 証明書
    linkTo: 証明書を追加
    noData: まだ証明書は定義されていません
  new:
    header: 証明書を追加
    form:
      name:
        placeholder: '例: mydomain.com'
      description:
        placeholder: '例: mydomain.com の EV 証明書'
membersPage:
  title: メンバー
  add:
    title: '{type} メンバーを追加'
    form:
      member: メンバー
      role: ロール
      kind: 種類
  index:
    localLink: 'メンバーを追加'
    table:
      name: 名前
      created: 作成日
      noData: まだメンバーはいません
      noMatch: 検索条件に一致するメンバーがいません
      userId: ユーザー
      subjectKind: 種類
      template: ロール
namespacesPage:
  header: 名前空間
  addNamespace: 名前空間を追加
  noMatch: 検索条件に一致する名前空間がありません
  noData: のクラスタでははまだ名前空間は定義されていません
  table:
    name:
      label: 名前空間
    description:
      label: 詳細情報
    project:
      label: プロジェクト
    pods:
      label: ポッド
    workloads:
      label: ワークロード
    created:
      label: 作成日
clusterPage:
  edit: クラスターを編集
  removeMemberNote: '注意: ユーザーを削除しても、プロジェクトのパーミッションは削除されません'
projectsListNamespacePage:
  header: 名前空間
  notIn: プロジェクト内にありません
projectsPage:
  header: プロジェクト/名前空間
  headerNS: 名前空間
  addProject: プロジェクトを追加
  editProject: プロジェクトを編集
  noMatch: 検索条件に一致するプロジェクトはありません
  noData: このクラスターではまだプロジェウトは定義されていません
  groups:
    none: 名前空間のリスト
    namespaces: グループ化されたプロジェクト/名前空間
  quota:
    label: リソース制限
  ns:
    label: 名前空間名
    placeholder: '例: lab'
  name:
    label: プロジェクト名
    placeholder: '例: lab'
  created:
    label: 作成日
  psp:
    label: ポッドセキュリティポリシー
  members:
    title: メンバー
    user: ユーザー
    group: グループ
    serviceaccount: サービスアカウント
    labelText: メンバー
    addMember: メンバーを追加
    addUser: ユーザーを追加
    noAddUser: あなたが唯一の有効な登録済みユーザーです
    addGroup: グループを追加
    addServiceAccount: サービスアカウントを追加
    multipleRoles: 複数ロール
    customRoles: カスタムロール
    kind:
      label: 種類
    name:
      label: 名前
    role:
      label: ロール
    errors:
      nameReq: 名前が必要です
      nameInExists: 名前は既に存在しています。新しいプロジェクト名を使用してください。
      memberNameReq: メンバーには名前が必要です
      memberRoleReq: メンバーにはロールが必要です
clustersPage:
  header: クラスター
  newCluster: クラスターを追加
  newClusterName: "クラスターを追加: {name}"
  editClusterName: "クラスターを編集: {name}"
  cluster:
    label: クラスター名
  provider:
    label: プロバイダー
  version:
    label: バージョン
  nodes:
    label: ノード数
  cpu:
    label: CPU
  memory:
    label: RAM
  pod:
    label: ポッド
  storage:
    label: ディスク
ingressPage:
  header: 'イングレス: {name}'
  table:
    targets:
      label: ターゲット
    noMatch: 検索条件に一致するイングレスがありません。
    noData: まだイングレスルールは定義されていません
containerPage:
  header: 'コンテナ: {name}'
  envTab:
    header: 環境変数
  portsTab:
    header: ポート
    detail: 'コンテナのリッスンしているポートとホストのパブリック IP アドレス上のポートのマッピングを設定します'
    hostPrimaryIp: '({ip})'
  linksTab:
    header: リンク
    detail: 'これらの属性値はこのコンテナと他のコンテナ間のリンク情報を示します'
    noData: このコンテナにはリンクはありません
  volumesTab:
    header: ボリューム
    detail: 'これらの属性値はコンテナにアタッチされているボリュームを示します'
    table:
      path: マウントポイント
      shared: 共有対象
      writable: 書き込み可能
      noData: このコンテナにはマウントされているボリュームがありません
      noMatch: 検索条件に一致するボリュームがありません
      noContainers: コンテナはありません
  pod: ポッド
podPage:
  header: 'ポッド: {name}'
  nodeIp: ノード IP
  podIp: ポッド IP
  containerImage: '{container} イメージ'
  image: イメージ
  displayImage: '{image} + {sidecar, plural, other {# images}}'
containersPage:
  table:
    sparkPrefixCpu: "CPU: "
    sparkPrefixMemory: "メモリ: "
    sparkPrefixNetwork: "ネットワーク: "
    sparkPrefixStorage: "ストレージ: "
    noData: 表示するコンテナはありません
    noMatch: 検索条件に一致するコンテナがありません
  welcome:
    container: 始めましょう
    containerLink: コンテナを追加
    orchestrator: 他のオーケストレーターをインストール
    kubernetesLink: Kubernetes をインストール
clusterDashboard:
  notActive: このクラスターは現在 <b>{state}</b> 状態です
  notReady: このクラスターは現在 <b>{state}</b> 状態です; API が準備されるまでこのページでの直接の操作はできません。
metricsAction:
  grafana:
    label: Grafana
metrics:
  pod-disk-io: ディスク I/O
  pod-memory-usage-bytes-sum: メモリ使用率
  pod-network-io: ネットワーク I/O
  pod-network-packet: ネットワークパケット
  container-cpu-usage: CPU使用率
  container-disk-io: ディスク I/O
  container-memory-usage-bytes-sum: メモリ使用率
dnsPage:
  noMatch: 検索条件に一致するレコードはありません
  noData: 表示する DNS レコードはありません
  type:
    arecord: 外部 IP
    cname: ホスト名
    alias: エイリアス
    workload: ワークロード
    selector: セレクター
    clusterIp: クラスター IP
    unknown: 不明
  table:
    target: 対象
    clusterIpDetail: 'クラスター IP: {ip}'
editDns:
  title:
    new: DNS レコードを追加
    edit: DNS レコードを編集
    view: "DNS レコード: {name}"
  name:
    placeholder: '例: myapp'
  externalIPs:
    placeholder: '例: 80.11.12.10'
    value: 外部 IP
  loadBalancerIP:
    label: ロードバランサー IP
    placeholder: '例: 78.11.24.19'
  loadBalancerSourceRanges:
    placeholder: '例: 143.231.0.0/16'
  healthCheckNodePort:
    placeholder: '例: 8080'
  externalTrafficPolicy:
    local: ローカル
    cluster: クラスター
  publishNotReadyAddresses:
    label: 公開されている IP アドレス
  sessionAffinityConfig:
    placeholder: '例: 10800'
  description:
    placeholder: '例: 最新版の MyApp'
  selector:
    label: コンテナ ラベルセレクター
    keyLabel: ラベル
    addActionLabel: セレクターを追加
  recordType:
    label: "解決方法"
    arecord: 1つ以上の外部 IP アドレス
    cname: 外部ホスト名
    alias: 別 DNS レコード値のエイリアス
    workload: 1つ以上のワークロード
    selector: セレクターに一致するポッドのセット
    clusterIp: "クラスター IP"
  target:
    arecord: ターゲット IP アドレス
    cname: ターゲット ホスト名
    alias: ターゲット DNS レコード
    workload: ターゲット ワークロード
    selector: ターゲット ポッドセレクター
  add:
    arecord: ターゲット IP を追加
    alias: ターゲット レコードを追加
    workload: ターゲット ワークロードを追加
    selector: ターゲット セレクターを追加
  placeholder:
    arecord: '例: 19.82.2.24'
    cname: '例: example.com'
  prompt:
    alias: DNS レコードを選択してください...
    workload: ワークロードを選択してください...
  errors:
    targetRequired: '1つ以上の "ターゲット IP アドレス" が必要です'
    selectorRequired: '1つ以上の "ポッドセレクター" が必要です'
    mixedAlias: エイリアスは CNAME と他のレコードを組み合わせて指定することはできません
    multipleCname: エイリアスは複数の CNAME レコードを指定することはできません
cruPersistentVolumeClaim:
  title:
    define: ボリューム要求を定義
    new: ボリューム要求を追加
    edit: 'ボリューム要求を編集: {name}'
    view: '永続ボリューム: {name}'
  define:
    addActionLabel: 定義
  capacity:
    label: 容量
    unit: GiB
  name:
    placeholder: '例: myvol'
  source:
    label: ソース
    pv: 既存の永続ボリュームを使用
    storageClass: 新しい永続ボリュームの作成にストレージクラスを使用
  pv:
    label: 永続ボリューム
    prompt: 永続ボリュームを選択してください...
  storageClass:
    label: ストレージクラス
    prompt: デフォルトクラスを使用
cruVolumeClaimTemplate:
  name:
    placeholder: '例: myvol'
  pv:
    label: 永続ボリューム
  storageClass:
    label: ストレージクラス
cruVolume:
  title:
    new: エフェメラルボリュームを定義
  define:
    addActionLabel: 定義
  name:
    placeholder: '例: myvol'
  source:
    label: ソース
    title: ソース設定
    detail: 選択中のボリュームソースのオプションを設定します
    prompt: ボリュームソースを選択してください...
globalDnsPage:
  entriesPage:
    table:
      name: 名前
      fqdn: FQDN
      provider: プロバイダー ID
    config:
      project: プロジェクト
      fqdn:
        label: FQDN
        placeholder: dev.example.com
      provider:
        label: プロバイダー
  providersPage:
    config:
      accessKey:
        label: アクセスキー
      secretKey:
        label: 秘密キー
failWhalePage:
  header: エラー
  reloadButton: |
    再度試してみるために以下を実施してください<br> <a href="#" onclick="window.location.href = window.location.href; return false;">再読み込み</a>または
  logoutButton: ログアウト
time:
  now: 今
  mins: |
    {mins, plural,
    =1 {# 分}
    other {# 分}
    }
  minsAgo: |
    {mins, plural,
    =1 {# 分前}
    other {# 分前}
    }
  secsAgo: |
    {secs, plural,
    =1 {# 秒前}
    other {# 秒前}
    }
haPage:
  header: 高可用性
  setup:
    prefix: "ホストの障害時に {appName} が稼働し続けるよう複数のサーバーコンテナを異なるホストにデプロイ出来ます。  "
    link: ドキュメントを参照してください
    suffix: "セットアップと使用方法についてご確認ください。"
  table:
    address: 通知アドレス
    port: ポート
    heartbeat: 最終通知時刻
    clustered: クラスター
nodesPage:
  header: ノード
  editCluster: クラスターを編集
  nodePoolGroup: "プール: {name}"
  table:
    clusterName: クラスター
    role: ロール
    cpu: CPU
    memory: RAM
    disk: ディスク
    pod: ポッド
    version: バージョン
    docker: Docker
    unschedulable: 未スケジュール
    instanceState: コンテナの状態
    instanceStateWithIcon: 状態
    noData: このクラスターではまだノードは定義されていません
    noMatch: 検索条件に一致するノードがありません
hostsPage:
  cloudHostsPage:
    addPage:
      launch: 起動
      header: ノードを追加
      name:
        label: ノード名
        placeholder: '例: node01'
      transferUnit: TB
      instance: 'タイプ:'
      storage: 'ストレージ'
      transfer: '転送量:'
      zone: 'ゾーン:'
      env: '環境:'
      size: 'サイズ:'
      os: 'OS:'
      driver: 'ドライバー:'
      template: 'テンプレート名:'
  addContainer: コンテナを追加
  new:
    header:
      customText: カスタムホストを追加
      text: ノードを追加
    manageLink: 利用可能なマシンドライバーを管理
    custom: カスタムホストを追加
    name:
      placeholder: '例: node01'
    addCluster:
      label: "クラスターオプション"
      description: この新しいnodeをクラスタに接続し、役割を委任するなど
      cluster:
        label: クラスター
      roles:
        label: ロール
      table:
        label:
          etcd: etcdとして利用
          control: 管理ノードとして利用
          worker: ワーカーノードとして利用
  hostPage:
    header:
      title: 'ノード: {name}'
    hostname: ホスト名
    ipAddress: IP アドレス
    version: バージョン
    kubeletVersion: Kubelet バージョン
    kubeProxyVersion: Kube Proky バージョン
    dockerVersion: Docker バージョン
    kernelVersion: カーネルバージョン
    operatingSystem: オペレーティングシステム
    conditions:
      diskSpace: ディスクスペース
      diskPressure: ディスク使用率
      memoryPressure: メモリ使用率
      ready: Kubelet
    limits:
      cpu: 'CPU 制限:'
      memory: 'メモリ制限:'
      storage: 'ローカルボリューム制限:'
    infoMultiStats:
      ip: 'IP'
      cpu: 'CPU'
      memory: 'メモリ'
      storage: 'ボリューム'
      provider:
        labelText: 'プロバイダー:'
        noHost: カスタム
      kernel: 'カーネル'
      docker: 'Docker:'
      os: 'OS'
      milliCpu:
        labelText: mCPU
    containersTab:
      header: コンテナ
      detail: このホスト上で稼働しているコンテナのリストです
    portsTab:
      header: ポート
      detail: 'これらの属性値はどのポートがどこにマッピングされているかを示します'
      table:
        header:
          ip: IP アドレス
          port: ポート
          service: サービス
          container: コンテナ
        body:
          noData: まだこのホストにはパブリックポートがありません
    storageTab:
      header: ボリューム
      detail: 'これらのプロパティはホスト上のボリュームの詳細を示します'
      table:
        header:
          state: 状態
          hostPath: ホストパス
          mounts: マウント
        body:
          noData: まだこのホストにはボリュームがありません
k8sImport:
  header: 既存の Kubernetes 環境をインポート
  name:
    label: クラスター名
    placeholder: '例: my-imported-cluster'
  kubeConfig:
    label: インポート用 Kubeconfig ファイル
    placeholder: 使用するクラスターの Kubeconfig ファイルをインポートまたはペーストします
  actionLabel: インポート
k8sPage:
  header: Kubernetes
  dashboard:
    title: ダッシュボード
    detail: Kubernetes のネイティブダッシュボードにアクセス
    button: ダッシュボードを起動
  shell:
    title: シェル
    detail: ブラウザから <code>kubectl</code> コマンドを実行します。
    button: kubectlを起動
  configFile:
    title: 設定ファイル
    detail: <code>kubectl</code> をデスクトップで利用するために Kubernetes 設定ファイルを生成します。
    button: Kubeconfigファイル
    generating: 生成中...
    usage:
      helpText: |
        以下を <code>~/.kube/config</code> に記述します:
      downloadText: |
        次に、(必要なら) <a href="{downloadUrl}" target="_blank">ダウンロード</a>したのち、<code>kubectl</code> を実行します。
loginPage:
  greeting: "こんにちは！<br><span>{appName} へようこそ</span>"
  githubMessage: "{appName} はアカウントやチームの管理に GitHub を利用しています。 ログインしてあなたの GitHub アカウント情報に読み込み権限でアクセスするために以下のボタンを押して下さい。"
  shibbolethMessage: "{appName} はアカウントの管理にシボレスを利用しています。 設定済みのシボレス IDP にログインするには以下のボタンを押して下さい。"
  shibbolethError:
    401: "認証に失敗しました"
    500: "サーバ内部エラー"
    generic: "ログイン中にエラー {errorCode} が発生しました。もう一度やり直してください。"
  error:
    authFailedCreds: "ログインに失敗しました: 認証情報が間違っているか、アカウントにログインする権限が与えられていない可能性があります。"
    authFailed: "ログインに失敗しました: アカウントにログインする権限が与えられていない可能性があります。"
  readableProviders:
    ad: Active Directory
    azureAd: Azure AD
    local: ローカルユーザー
    openldap: OpenLDAP
    freeipa: FreeIPA
machinePage:
  header: ノードドライバー
  inactive: 休止
  subtext: "追加の <code>docker-machine</code> ドライバーをここからロードして、ノードの追加画面で利用することができます。"
  add: ノードドライバーを追加
  builtin: ビルトイン
  url: ロケーション
notFoundPage:
  header: "お探しのページは存在しません!"
  linkTo: ホームに戻る
registriesPage:
  index:
    header: レジストリ
    linkTo: レジストリを追加
    table:
      header:
        state: 状態
        address: アドレス
        username: ユーザー名
        created: 作成日
      body:
        noData: "まだレジストリの資格情報がありません"
  new:
    header: レジストリを追加
    form:
      custom:
        labelText: アドレス
        placeholder: '例: registry.example.com'
        help: プロトコル (https://) を含まないホスト名または IP アドレス
      username:
        labelText: ユーザー名
        placeholder: '例: username'
      password:
        labelText: パスワード
        placeholder: '例: password'
secretsPage:
  index:
    header: シークレット
    linkTo: シークレットを追加
    noData: まだシークレットは定義されていません
    noMatch: 検索条件に一致するシークレットがありません
  table:
    keys: キー
configMapsPage:
  index:
    header: コンフィグマップ
    linkTo: コンフィグマップを追加
    noData: まだコンフィグマップは定義されていません
    noMatch: 検索条件に一致するコンフィグマップはありません
  table:
    keys: キー
servicePage:
  header: 'ワークロード: {name}'
  globalScale: 'ホスト毎に {scale}'
  endpoints: 'エンドポイント:'
  multistat:
    type: 'ワークロードタイプ:'
    fqdn: 'FQDN:'
    scale: 'スケール:'
    image: 'イメージ:'
    namespace: '名前空間:'
    created: '作成日:'
    daemonSetScale: 'ノード毎に 1 つ'
  serviceType:
    deployment: デプロイメント
    replicaSet: レプリカセット
    statefulSet: ステートフルセット
    daemonSet: デーモンセット
    replicationController: レプリケーションコントローラー
    job: ジョブ
    cronJob: クーロンジョブ
    pod: スタンドアローンポッド
  external:
    externalIp: |
      {count, plural,
      =1 {外部IP:}
      other {外部IP:}
      }
    externalHostname: '外部ホスト名:'
  selector:
    label: 'セレクター:'
  containersTab:
    title: 'コンテナ'
    detail: 'このサービスを構成するコンテナ。'
  linksTab:
    header: リンク
    detail: 'これらの属性値はこのサービスと他のコンテナ間のリンク情報を示します'
    noData: このサービスにはリンクはありません
  certsTab:
    title: 証明書
    detail: '証明書はリクエストの TLS 終端処理に利用されます'
    default: デフォルト証明書
    additional: 追加の SNI 証明書
  new:
    form:
      name:
        placeholder: '例: myapp'
      description:
        placeholder: '例: マイアプリケーション'
  newBalancer:
    upgradeImage: "バランサーのソフトウェア イメージは、<code>{from}</code> から <code>{to}</code> にアップグレードされます。"
    form:
      name:
        placeholder: '例: ウェブサイト'
      description:
        placeholder: '例: mycompany.com に対してのバランサー'
  newIngress:
    form:
      name:
        placeholder: '例: ウェブサイト'
      description:
        placeholder: '例: mycompany.comのイングレス'
  portsTab:
    title: ポート
    detail: 'ホストIPからコンテナのリスニングポートにマッピングされたポート。'
    notActive: ポートはサービスがアクティブの場合のみ利用できます。
  logTab:
    title: サービスログ
    detail: 'このサービスに関して直近のオーケストレーションで発生したイベント情報です'
  type:
    service: サービス
    selectorservice: セレクター
    loadbalancerservice: ロードバランサー
    dnsservice: エイリアス
    externalservice-ip: 外部 IP アドレス
    externalservice-host: 外部名
    kubernetesservice: K8s サービス
    composeservice: 構成サービス
    networkdriverservice: ネットワークサービス
    storagedriverservice: ストレージサービス
  sidekick:
    tabHeader: サイドカー
    header: ワークロード & サイドカー
    helpBlock: メインコンテナもしくはサイドカーを選択してください
signupPage:
  header: '{appName} にサインアップ'
  form:
    button: 登録
    labels:
      loginUsername: ユーザー名
      email: E-mail アドレス
  emailSuccess:
    header: '{appName} へようこそ'
    confirm:
      subtext: 送信済みのメールから確認用リンクをクリックしてください
      resend: メールを再送信
stackPage:
  header:
    singleBanner: 単一スタックビュー
    backLink: 全てのスタック表示に戻る
  basics:
    tagsCopy: タグをカンマ区切りリストとしてコピーする
  containers:
    header: コンテナ
    detail: このスタックに含まれるスタンドアロンコンテナとサービス
    status: |
      {count, plural,
      =0 {コンテナはありません}
      =1 {# コンテナ}
      other {# コンテナ}
      }
  loadBalancers:
    header: ロードバランサー
    detail: 'ロードバランサーコンテナはこのスタックに含まれています'
    status: |
      {count, plural,
      =0 {バランサーはありません}
      =1 {# バランサー}
      other {# バランサー}
      }
  dnsServices:
    header: DNS エントリ
    detail: 'ロードバランサーはこのスタックに含まれています'
    status: |
      {count, plural,
      =0 {エントリーはありません}
      =1 {# エントリー}
      other {# エントリー}
      }
  scalingGroups:
    header: スケーリンググループ
    detail: 'このスケーリンググループに存在するコンテナ'
    status: |
      {count, plural,
      =0 {コンテナはありません}
      =1 {# コンテナ}
      other {# コンテナ}
      }
  volumesTab:
    header: ボリューム
    detail: 'これらのプロパティは、コンテナに接続されたボリュームを示します。'
    table:
      path: マウントポイント
      shared: 共有者
      writable: 書き込み可能
      noData: このスタックにはマウントされているボリュームがありません
      noMatch: 検索条件に一致するボリュームがありません
newStack:
  header: YAML をインポート
  name:
    placeholder: '例: myapp'
  description:
    placeholder: '例: MyApp スタック'
  files:
    label: ファイル
    addActionLabel: ファイルを追加
    uploadActionLabel: ディスクから読み込み
    namePlaceholder: ファイル名
    valuePlaceholder: ファイルの内容
    protipLabel: '{appName} <code>compose.yml</code>, <code>docker-compose.yml</code> または Kubernetes マニフェストファイルがサポートされます'
  answers:
    label: 回答(変数置換を含む)
    addActionLabel: 回答を追加
nodeTemplatesPage:
  header: ノードテンプレート
  detail: ノードテンプレートはインフラストラクチャプロバイダー上のクラスターに所属するノードを展開する際に利用されます
  table:
    state: 状態
    name: 名前
    provider: プロバイダー
    location: ロケーション
    size: サイズ
    usedBy: 利用クラスタ
    noData: まだノードテンプレートは定義されていません
    usedByNone: クラスターに利用されていません
    unknown: 不明
storageClassPage:
  header: ストレージクラス
  addActionLabel: クラスを追加
  noData: まだストレージクラスは定義されていません
  noMatch: 検索条件に一致するストレージクラスはありません
  provisioner:
    label: プロビジョナー
  default:
    label: デフォルト
persistentVolumePage:
  header: 永続ボリューム
  addActionLabel: ボリュームを追加
  noData: まだ永続ボリュームは定義されていません
  noMatch: 検索条件に一致する永続ボリュームはありません
  source:
    label: ソース
userPreferencesPage:
  header: アカウント設定
  theme:
    header: テーマ
    light: Light
    auto: 自動
    autoDetail: 自動では 6pm-6am の間 dark に変わります
    dark: Dark
  generalInfo:
    header: マイアカウント
    name:
      label: 名前
    username:
      label: ユーザー名
    email:
      label: E メールアドレス
    password:
      text: パスワードを変更
verifyPage:
  header: "E メールアドレスの検証に成功しました!"
  subtext: アカウント情報の処理を完了する前にさらにいくつかの情報を入力する必要があります
  account:
    header: アカウントは作成されました
    subtext: ログインページに移動するには、以下のリンクをクリックします
    linkText: ログイン
verifyResetPasswordPage:
  header: パスワードをリセット
  button: パスワードを更新
  success:
    header: パスワードはリセットされました!
    subtext: ログインページに移動するには、以下のリンクをクリックします
    linkText: ログイン
waitingPage:
  hosts:
    setup:
      kubernetes: Kubernetes をセットアップ
notifierPage:
  notifiers: 通知
  testedBtnLabel: OK
  testingBtnLabel: テスト中
  deleteErrorMessage: '通知 {displayName} は {alertNames} で利用されています'
  notifierTypes:
    slack: Slack
    email: E-mail アドレス
    pagerduty: PagerDuty
    webhook: Webhook
    wechat: WeChat
  slack:
    url: URL
    urlPlaceholder: '例: https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX'
    defaultRecipientPlaceholder: '例: #example'
    helpText: |
      Slack 用 <a href="https://get.slack.help/hc/en-us/articles/115005265063-Incoming-WebHooks-for-Slack">incoming WebHooks の作成</a> を参照してください
  smtp:
    server: SMTP サーバー
    host: ホスト
    hostPlaceholder: '例: 192.168.1.121'
    port: ポート
    portPlaceholder: '例: 465'
    sender: 送信者
    userName: ユーザー名
    userNamePlaceholder: '例: John'
    password: パスワード
    passwordPlaceholder: あなたのパスワード
    defaultRecipientPlaceholder: '例: admin@example.com'
  pagerduty:
    serviceKeyPlaceholder: あなたの pagerduty サービスキー
    helpText: |
      Pagerduty 用 <a href="https://support.pagerduty.com/docs/webhooks">incoming WebHooks の作成</a> を参照してください
  wechat:
    agentPlaceholder: '例: 1000003'
    corpPlaceholder: '例: wwc0cc3d58f9b021b6'
    defaultRecipientPlaceholder: '例: 2'
  webhook:
    url: URL
    urlPlaceholder: あなたの webhook URL
  testAction:
    testing: テスト中
    testOk: 設定が確認されました
    testFailed: 何かが正しくないようです。入力内容を確認してください。
    test: テスト
  clone: クローン
  index:
    addActionLabel: 通知を追加
    table:
      created: 作成日
      noData: まだ通知は定義されていません
      noMatch: 一致しません
ldap:
  providerName:
    openldap: OpenLDAP
    ad: Active Directory
    freeipa: FreeIPA
    saveLabels:
      openldap: OpenLDAPによる認証
      ad: Active Directoryによる認証
      freeipa: FreeIPAによる認証
  header:
    disabled:
      label: "{providerName} は設定されていません"
  accessEnabled:
    header: 認証
    subtext: "サーバー設定を変更するには以下のアクセスコントロールを無効化し、再度設定し直して下さい。"
    general:
      header: 一般
      server: "サーバー:"
      tls: "TLS:"
      serviceAccount: "サービスアカウント:"
      searchBase: "サーチベース:"
      defaultDomain: "デフォルトドメイン:"
    users:
      header: ユーザー
      objectClass: "オブジェクトクラス:"
      login: "Login Field:"
      name: "Name Field:"
      search: "Search Field:"
      enabled: "Status Field:"
      disabledBitMask: "Disabled BitMask:"
    group:
      header: グループ
      objectClass: "オブジェクトクラス:"
      name: "Name Field:"
      search: "Search Field:"
    disable:
      confirmDisable:
        pre: アクセスコントロールを無効化
  accessConfig:
    header: "1. {providerName} サーバーを設定"
    subtext1: "あなたの {providerName} サーバーに接続するため、アドレス、ポート、プロトコルを入力してください。通常は <code>389</code> 番ポートが利用され、<code>636</code>はTLSに利用されます。"
    subtext2: "{appName} はユーザーがどのグループに所属しているか、いつ API キーでリクエストを発行したかなどを特定し、ログイン処理を実行するために全てのドメインに対して (read-only) アクセスが可能なサービスアカウントを必要とします。"
    port:
      labelText: ポート
      checkbox: TLS
    groupSearchBase:
      labelText: グループ サーチベース
      placeholder: "例: ou=Groups,dc=mycompany,dc=com"
      helpText: "設定した場合、ユーザー検索ベースの代わりにこちらのベースがグループの検索に利用されます"
    userSearchBase:
      labelText: ユーザーサーチベース
      placeholder: "例: ou=users,dc=mycompany,dc=com"
    defaultDomain:
      helpText: "一部を除き、ユーザーがログインする際このドメインが使用されます。"
      labelText: デフォルト ログインドメイン
      placeholder: "例: mycompany"
    connectionTimeout:
      labelText: サーバー接続タイムアウト
  customizeSchema:
    header: "2. スキーマのカスタマイズ"
    helpText: "スキーマが標準的な ActiveDirectory フォーマットに一致しない場合、こちらでカスタマイズすることができます。"
    cert:
      labelText: CA 証明書
      helpText: 必要に応じて CA 証明書を入力してください
      placeholder: "-----BEGIN CERTIFICATE----- から始まる証明書をペーストしてください"
    users:
      header: ユーザー
      objectClass:
        labelText: オブジェクトクラス
      login:
        labelText: ログイン属性
      name:
        labelText: ユーザー名属性
      search:
        labelText: サーチ属性
      searchBase:
        labelText: ユーザーサーチベース
      enabledAttribute:
        labelText: ユーザー有効化属性
      disabledBitMask:
        labelText: Disabled Status Bitmask
      userMemberAttribute:
        labelText: ユーザーメンバー属性
    groups:
      header: グループ
      objectClass:
        labelText: オブジェクトクラス
      name:
        labelText: 名前属性
      search:
        labelText: サーチ属性
      groupMemberUser:
        labelText: グループメンバーのユーザー属性
        placeholder: uid
      groupMemberMapping:
        labelText: グループメンバー マッピング属性
      groupDN:
        labelText: グループ DN 属性
        placeholder: 識別名
  testAuth:
    header: "3. テストのうえ認証を有効化する"
    helpText: "あなたの {providerName} アカウントで認証テストを行うことで全てが正常に設定されたことを確認します:"
    userName:
      labelText: ユーザー名
    password:
      labelText: パスワード
    authenticate:
      pre: 認証
      post: "テスト中..."
servicePartial:
  noContainers:
    label: まだコンテナはありません
    inactive:
      start: 開始
accordionRow:
  status:
    none: なし
    incomplete: 未完了
    error: エラー
    notConfigured: 未設定
    configured: 設定済み
    countConfigured: "{count} 設定済み"
    standard: デフォルト
    custom: カスタマイズ済み
    specific: 特定
    any: どれか
    rule: "{count, plural, =1 {# ルール} other {# ルール}}"
advancedSection:
  showText: 詳細オプションを表示
  hideText: 詳細オプションを隠す
annotationsSection:
  title: アノテーション
  detail: キー/値メタデータ
  key: キー
  value: 値
  noData: アノテーションはありません。
  noMatch: 検索条件に一致するアノテーションがありません
authorizedEndpoint:
  fqdn:
    label: FQDN
taintsSection:
  key: キー
  value: 値
  effect: 効果
billingInfo:
  header: 請求情報
  addNew: 支払い方法を追加
  card: "{brand}: ...{last}"
  noSub: アクティブな請求情報がありません
  table:
    title:
      cardType: "ブランド: {brand}"
      last4: "下4桁: {last}"
      exp: "有効期限: {exp}"
      name: "カード記載名: {name}"
      actions: アクション
cloudProvider:
  title: クラウドプロバイダー
  amazon: Amazon
  azure: Azure
  name: クラウドプロバイダ名
  helpText: |
    詳細は <a href="https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/" target="_blank" rel="nofollow noopener noreferrer">クラウドプロバイダーについて</a> を参照してください
  warning: クラウドプロバイダー設定を与えずにクラウドプロバイダーを使用すると、クラスターが正常に作成されない可能性があります。クラスターを作成する前にクラウドプロバイダー設定を追加することをお勧めします。
catalogSettings:
  header: カタログ
  notAvailable: "利用不可: <code>{name}</code> というカスタムカタログがあります"
  helpText: 現在は Helm カタログのみサポートされます
  currentCluster: クラスター
  currentProject: プロジェクト
  globalCatalog: グローバル
  library:
    label: ライブラリ
    detail: 公式に管理されているアプリケーション定義のリポジトリであり、{appName} によりメンテナンスされています。
  helm:
    stable:
      label: 安定版 Helm
      detail: 公式に管理されているアプリケーション定義のリポジトリであり、Kubernetes コミュニティによりメンテナンスされています。
    incubator:
      label: インキュベーター版 Helm
      detail: まだ安定していないベータ版アプリケーション定義のリポジトリです。
  certified:
    header:
      rancher: "{appName} 認証済みライブラリ"
      pl: 認証済みライブラリ
    detail:
      rancher: テンプレートは Kubernetes オーケストレーションサポートのような Rancher のコアとなる機能に必要となり、Rancher Labs によりメンテナンス、サポートされます。
      pl: 公式にメンテナンスされているテンプレートは Kubernetes のようなコアとなる機能に必要となります。
  community:
    header:
      rancher: コミュニティサポート
      pl: コミュニティサポート
    detail:
      rancher: テンプレートはコミュニティメンバーによって作成、メンテナンスされ、Rancher Labs によって認証されていません。
      pl: テンプレートはコミュニティメンバーによって作成、メンテナンスされ、
  more:
    header: カスタム
    helpText:
      help-repo: '<strong>リポジトリURL:</strong>'
    addActionLabel: カタログを追加
    noMatch: 検索条件に一致するカタログがありません。
    noData: まだカスタムカタログは定義されていません
    addHeader: カタログを追加
    editHeader: カタログを編集
    name:
      label: 名前
      placeholder: '例: my catalog'
    url:
      label: URL
    kind:
      label: 種類
      native: ネイティブ
      helm: Helm
    branch:
      label: ブランチ
      placeholder: '例: master'
clusterRow:
  noMatch: 検索条件に一致する環境がありません。
  noData: このクラスターにはまだ環境はありません。
  noHosts: 外部クラスタにはノードがありません
  noClusterMatch: 検索条件に一致するクラスターがありません。
  noClusterData: まだクラスターはありません
  addHost: ノードを追加
  importCluster: 既存の Kubernetes を利用
  loginDefault: ログイン
clusterNew:
  advanced:
    cancel: フォームで指定
    yaml: YAML として編集
  name:
    label: クラスター名
    placeholder: '例: sandbox'
  description:
    placeholder: '例: 開発やテスト用のクラスター'
  driverLabels:
    import: 既存のクラスターをインポート
  members:
    label: メンバーの役割
    detail: クラスターに誰がアクセスでき、どのような権限を保持するかを制御します
  config:
    label: プロバイダー
    detail: クラスターに追加されるノードをどこに起動するか選択してください
  nodes:
    title: ノード
    detail: 作成されるノードをカスタマイズする
  customize:
    title: クラスターオプション
    detail: 作成されるクラスターをカスタマイズする
  psp:
    label: 既定のPodセキュリティポリシー
    prompt: ポッドセキュリティポリシーを選択...
    none: ポリシーが定義されていません。
    required: サポートが有効になっている場合、デフォルトのポッドセキュリティポリシーが必要です。
  amazoneks:
    label: Amazon Elastic Container Service for Kubernetes
    shortLabel: Amazon EKS
    access:
      title: アカウントアクセス
      detail: Amazon EKS の起動に使用するリージョンと API キーを選択してください
  azureaks:
    label: Azure Container Service
    shortLabel: Azure AKS
    authenticate:
      next: "次へ: 認証とノードの設定"
    access:
      title: アカウントアクセス
      detail: Azure の操作に使用する認証情報を設定する
      help: 'クライアント ID とシークレットを作成する手順は <a href="https://www.packer.io/docs/builders/azure-setup.html" target="_blank">こちら</a> から参照できます'
    placement:
      label: 配置
    count:
      label: ノード数
    location:
      label: ロケーション
      prompt: ロケーションを選択してください...
    accountAccessSection:
      label: アカウントアクセス
    subscriptionId:
      label: サブスクリプション ID
      placeholder: あなたの Azure サブスクリプション ID
    machineType:
      label: VM サイズ
      prompt: サイズを選択してください...
    diskSizeGb:
      label: OSディスクサイズ
    dns:
      placeholder: "例: example"
    ssh:
      label: SSH 公開鍵
    security:
      label: セキュリティ
    members:
      label: メンバーロール
    pod:
      label: ポッドセキュリティポリシー
    kubernetesVersion:
      label: Kubernetesのバージョン
      prompt: バージョンを選択してください...
    admin:
      label: 管理者ユーザー名
      placeholder: user-1
    tenant:
      label: テナント ID
      placeholder: あなたの Azure テナント ID
    image:
      label: イメージ
      placeholder: 'canonical:UbuntuServer:16.04.0-LTS:latest'
    size:
      label: サイズ
    dockerPort:
      label: Docker ポート
      placeholder: '2376'
    publishSettingsFile:
      label: 公開設定
      placeholder: あなたの公開設定ファイル
    environment:
      label: 環境
    resourceGroup:
      label: リソースグループ
      placeholder: 'docker-machine'
    networking:
      label: ネットワー キング
      default: デフォルト
      advanced: 詳細
      subnet:
        label: サブネット
      serviceCidr:
        prompt: "10.43.0.0/16"
    sshUser:
      label: SSH ユーザー
      placeholder: usr1
    storageType:
      label: ストレージタイプ
    vnet:
      label: VNet
      placeholder: '[resourcegroup:]name'
    subnet:
      label: サブネット
      placeholder: example-sub-name
    subnetPrefix:
      label: サブネットプリフィックス
      placeholder: 128.42.0.0/21
    availabilitySet:
      label: 可用性セット
      placeholder: 可用性セット名
    openPort:
      label: 公開ポート
      placeholder: 'カンマ区切りの番号, 例: 80,443'
    privateIpAddress:
      label: プライベート IP
      placeholder: 127.0.0.1
    usePrivateIp:
      label: プライベートIPを使用して接続
    staticPublicIp:
      label: パブリック IP
    noPublicIp:
      label: パブリックIPはありません
    clientId:
      label: クライアント ID
      placeholder: あなたのクライアント ID
    clientSecret:
      label: クライアントシークレット
      placeholder: あなたのクライアントシークレット
    region:
      label: リージョン
  googlegke:
    label: Google Kubernetes Engine
    shortLabel: Google GKE
    checkServiceAccount: "次へ: ノードの設定"
    checkingServiceAccount: 認証中...
    credential:
      label: サービスアカウント
      placeholder: サービスアカウントの秘密鍵 JSON ファイル
      configured: '{project} プロジェクト用に設定されています'
      helpText: |
        <a href="https://console.cloud.google.com/projectselector/iam-admin/serviceaccounts" target="_blank" rel="nofollow noopener noreferrer">サービスアカウント</a> を JSON 形式のプライベートキーととも>に作成し、ここに記載してください。サービスアカウントの作成に関する詳細は <a href="https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances" target="_blank" rel="nofollow noopener noreferrer">Google Cloud ドキュメント</a> を参照してください。また、次の3つの IAM アカウントが必要となりますのでご注意ください: <code>project/viewer</code>, <code>kubernetes-engine/admin</code>, <code>service-account/user</code>, ロールに関しての詳細な情報は <a href="https://cloud.google.com/kubernetes-engine/docs/how-to/iam-integration" target="_blank" rel="nofollow noopener noreferrer">こちら</a> を参照してください。
    zone:
      label: ゾーン
      prompt: ゾーンを選択...
    project:
      label: プロジェクト
      placeholder: '例: my-project'
    machineType:
      label: マシンタイプ
      prompt: タイプを選択してください...
    nodeCount:
      label: ノード数
      prompt: タイプを選択してください...
    diskSizeGb:
      label: ルートディスクサイズ
    masterVersion:
      label: Kubernetes バージョン
      prompt: バージョンを選択してください...
    clusterIpv4Cidr:
      label: コンテナのアドレス範囲
      placeholder: '例: 10.42.0.0/16'
    alphaFeatures:
      label: アルファ機能
    stackDriverLogging:
      label: Stackdriver Logging
    stackdriverMonitor:
      label: Stackdriver Logging
    dashboard:
      label: Kubernetes ダッシュ ボード
    httpLB:
      label: Http ロードバランサー
    enableHorizontalPodAutoscaling:
      label: 水平ポッドオートスケーリング
  rke:
    etcd:
      heartbeat:
        label: etcd のハートビート間隔
        placeholder: ハートビート間隔の時間
      election:
        label: etcd 選出タイムアウト
        placeholder: 選出タイムアウトまでの時間
    nodeName:
      title: ノード名
      placeholder: '例: my-worker-node'
    address:
      title: ノードアドレス
      detail: ノードのパブリック IP とプライベート IP を設定します
      warning: 無効なアドレスです
      public:
        label: パブリック IP
        placeholder: '例: 1.2.3.4'
      private:
        label: プライベート IP
        placeholder: '例: 1.2.3.4'
    label: '{appName} Kubernetes Engine'
    shortLabel: カスタム
    customize:
      label: クラスターオプション
      detail: "クラスター用 Kubernetes オプションをカスタマイズします"
    labels:
      title: ノードラベル
      detail: ホストに適用するオプションラベル
    nodes:
      title: ノードプール
      detail: クラスターに所属するマシンの設定します
      add: ノードプールを追加
      addTemplate: ノードテンプレートを追加
      templatePrompt: "テンプレートを選択してください..."
      hostnamePrefix: ノード名プリフィックス
      count: 数
      template: テンプレート
    detected: |
      {count, plural,
      =1 {# 台の新しいノードが登録されました}
      other {# 台の新しいノードが登録されました}
      }
    done: 完了
    command:
      instructions: '以下のコマンドを既にサポート済みバージョンの Docker が動作している既存マシン上で実行してください'
    auth:
      label: 認証プロバイダー
      x509: x509
    serviceNodePortRange:
      label: ポート範囲を追加
      placeholder: '例: 30000-32767'
    network:
      label: ネットワークプロバイダー
      flannel: Flannel
      calico: Calico
      canal: Canal
      options:
        flannel:
          iface:
            label: インターフェース
        canal:
          iface:
            label: インターフェース
        calico:
          cloudProvider:
            label: クラウドプロバイダー
      type:
        info: '"host-gw" バックエンドのみをサポート'
    ingress:
      label: イングレス プロバイダー
    networkPolicy:
      label: プロジェクトのネットワーク分離
    version:
      label: Kubernetes バージョン
    registry:
      label: Kubernetes イメージの取得先
      default: デフォルトのレジストリ (DockerHub)
      custom: "カスタムレジストリ:"
      url:
        label: URL
        placeholder: '例: quay.io'
      user:
        label: ユーザー名
      password:
        label: パスワード
    ignoreDockerVersion:
      label: ノードの Docker バージョン
      enabled: 未サポートのバージョンを許可
      disabled: サポートされている Docker バージョンを要求
    podSecurityPolicy:
      label: ポッドセキュリティポリシー サポート
    role:
      sectionheader: ノードオプション
      title: ノードロール
      detail: ノードがクラスター内でどのロールとして動作するか選択してください
      header:
        etcd: etcd
        controlplane: Control
        worker: Worker
      requirements:
        label: "必要なノード数:"
        etcd: 1, 3, または 5
        controlplane: 1 つ以上
        worker: 1 つ以上
    kubeApi:
      label: Kube API
      ipRange: サービスクラスターの IP 範囲
      podSecurityPolicy: ポッドセキュリティポリシー
    kubeController:
      label: Kube Controller
      cidr: クラスター CIDR
      ipRange: サービスクラスターの IP 範囲
    kubelet:
      label: Kubelet
      domain: クラスタードメイン
      dns: クラスター DNS サーバー
    warning:
      aws:
        iam: 'Amazonのクラウドプロバイダーを使用する場合は、ノードテンプレートでIAMロール名を指定する必要があります'
    errors:
      etcd: etcd を使うには 1, 3 または 5 台のノードを選択してください
      controlPlane: Control を使うには少なくとも1台のノードを選択してください
      worker: Worker を使うには少なくとも1台のノードを選択してください
    dockerRootDir:
      placeholder: デフォルトディレクトリは {dir} です。
    system:
      title: ノードオペレーティングシステム
      linux: Linux
      windows: Windows
    windowsSupport:
      disabled: ネットワークプロバイダーの {plugin} はサポートされていません
  custom:
    label: カスタム
    shortLabel: カスタム
  import:
    label: インポート
    shortLabel: インポート
    command:
      instructions: "{appName} にインポートするには以下の kubectl コマンドを既存の Kubernetes 1.8.x クラスター上で実行してください:"
      instructionsInsecure: "'certificate signed by unknown authority' のようなエラーが発生した場合はあなたの {appName} が公式の CA から署名された SSL 証明書を利用していないことが原因です。証明書チェック>を回避するには以下のコマンドを実行してください。:"
conditionSections:
  title: コンディションはありません
  detail: '{resourceType} の現在のコンディションです'
  table:
    type: タイプ
    status: ステータス
    lastUpdate: 最終更新
    reason: 理由
    message: メッセージ
  noData: コンディションはありません
  noMatch: 検索条件に一致するコンディションはありません
resourceEventList:
  detail: '{resourceType} の現在のイベントです'
  table:
    type: タイプ
    lastUpdate: 最終更新
    reason: 理由
    message: メッセージ
  noData: イベントはありません
  noMatch: 検索条件に一致するイベントはありません
confirmDelete:
  titleWithoutResourceType: '本当に削除してもよろしいですか?'
  environmentNote: 'ノート: このプロジェクト内にある {appName} により作られた名前空間を含むの全てのリソースは完全に削除されます'
  clusterNote: '注意: クラウドプロバイダーにより作成されたボリューム、ロードバランサー、ネットワークなどの関連リソースは自動的には削除されません。'
  protip: 'ProTip: この確認画面を飛ばす場合は削除ボタンのクリック時に {key} キーを長押ししてください。'
  confirmAction: 削除
  cancelAction: キャンセル
  largeDeleteText: '{key} さんと他 {othersCount} 人'
containerLogs:
  title: "ログ: "
  onlyCombined: "<b>Note:</b> このコンテナでは TTY (-t) フラグが有効なため、標準出力/標準エラー出力が結合されたログのみが利用可能です。"
  combined: 結合された出力
  stdout: 標準出力
  stderr: 標準エラー出力
  protip: "ProTip: 新しいウィンドウで起動する場合はログを開く際に {key} を長押ししてください。"
  scrollTop: トップにスクロール
  scrollBottom: 下部にスクロール
  clear: スクリーンをクリア
  wrapLines: 行を折り返し
  status:
    initializing: 初期化中...
    connecting: 接続中...
    connected: 接続完了
    disconnected: 切断
    closed: 閉じる
containerShell:
  protip: "ProTip: 新しいウィンドウで起動する場合はシェルアクセスを開く際に {key} を長押ししてください。"
  status:
    initializing: 初期化中...
    error: "エラー: {error}"
    connecting: 接続中...
    connected: 接続完了
    disconnected: 切断
    closed: 閉じる
copyToClipboard:
  tooltip: クリップボードにコピー
  copied: コピーしました!
cruRegistry:
  title:
    new: レジストリを追加
    edit: 'レジストリの編集: {name}'
    view: 'レジストリ: {name}'
  address:
    label: アドレス
    dockerhub: DockerHub
    quay: Quay.io
    custom: カスタム
    placeholder: '例: registry.example.com'
  multiple: 複数
  auth:
    label: 認証トークン
    saved: 保存しました
  username:
    label: ユーザー名
  password:
    label: パスワード
    saved: 保存しました
cruPersistentVolume:
  name:
    placeholder: '例: myvolume'
  description:
    placeholder: '例: Volume for production database'
  title:
    new: 永続ボリュームを追加
    edit: '永続ボリュームを編集: {name}'
    view: '永続ボリューム: {name}'
  storageClass:
    label: ストレージクラスに割当
    prompt: None
  pvc: 永続ボリューム要求
  reclaimPolicy: 要求ポリシー
  capacity:
    label: 容量
    unit: GiB
  source:
    label: ボリュームプラグイン
    title: プラグイン設定
    detail: 選択したボリュームプラグインにオプションを設定します
    prompt: ボリュームプラグインを選択してください...
  customize:
    title: カスタマイズ
    detail: カスタマイズ用の拡張オプションです
  mountOptions:
    label: マウントオプション
    addActionLabel: オプションを追加
    noData: マウントオプションはありません
  awsElasticBlockStore:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    readOnly:
      label: 読み取り専用
    partition:
      label: パーティション
      placeholder: "例: 1; 0 for entire device"
    volumeID:
      label: ボリューム ID
      placeholder: "例: volume1"
  azureDisk:
    cachingMode:
      label: キャッシュモード
      none: なし
      readOnly: 読み取り専用
      readWrite: 読み書き
    diskName:
      label: ディスク名
      placeholder: "例: kubernetes-pvc"
    diskURI:
      label: ディスク URI
      placeholder: "例: https://example.com/disk"
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    kind:
      label: 種類
      dedicated: 専用
      managed: マネージド
      shared: 共有
    readOnly:
      label: 読み取り専用
  secret:
    defaultMode:
      label: デフォルトモード
      placeholder: "例: 256"
    optional:
      label: オプション
    secretName:
      label: シークレット
    certificateName:
      label: 証明書
    items:
      label: 項目
  configMap:
    defaultMode:
      label: デフォルトモード
      placeholder: "例: 256"
    optional:
      label: オプション
    name:
      label: コンフィグマップ名
    items:
      label: アイテム
  emptyDir:
    medium:
      label: Medium
      default: Node's Default Medium
      memory: メモリ
    sizeLimit:
      label: サイズ制限
      placeholder: "例: 300Mi"
  azureFile:
    secretName:
      label: シークレット名
      placeholder: "例: secret"
    secretNamespace:
      label: シークレット名前空間
      placeholder: "例: default"
    shareName:
      label: 共有名
      placeholder: "例: abc"
    readOnly:
      label: 読み取り専用
  cephfs:
    monitors:
      label: モニター
      addActionLabel: 追加
    path:
      label: パス
      placeholder: "例: /var"
    readOnly:
      label: 読み取り専用
    secretFile:
      label: シークレットファイル
      placeholder: "例: secret"
    secretRef:
      name:
        label: 名前
        placeholder: "例: abc"
      namespace:
        label: 名前空間
        placeholder: "例: default"
      label: シークレット
    user:
      label: ユーザー
      placeholder: "例: root"
  rbd:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    image:
      label: イメージ
      placeholder: "例: image"
    keyring:
      label: キーリング
      placeholder: "例: /etc/ceph/keyring"
    monitors:
      label: モニター
      addActionLabel: 追加
    pool:
      label: プール
      placeholder: "例: rbd"
    readOnly:
      label: 読み取り専用
    secretRef:
      label: シークレット
      placeholder: "例: secret"
    user:
      label: ユーザー
      placeholder: "例: root"
  fc:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    lun:
      label: LUN 番号
      placeholder: "例: 2"
    readOnly:
      label: 読み取り専用
    targetWWNs:
      label: ターゲット WWN
      addActionLabel: 追加
    wwids:
      label: WWID
      addActionLabel: 追加
  flexVolume:
    driver:
      label: ドライバー
      placeholder: "例: driver"
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    options:
      label: オプション
      addActionLabel: 追加
    readOnly:
      label: 読み取り専用
    secretRef:
      label: シークレット
      placeholder: "例: secret"
  flocker:
    datasetName:
      label: データセット名
      placeholder: "例: dataset"
    datasetUUID:
      label: データセット UUID
      placeholder: "例: uuid"
  glusterfs:
    endpoints:
      label: エンドポイント
      placeholder: "例: 10.240.106.152:1"
    path:
      label: パス
      placeholder: "例: kube_vol"
    readOnly:
      label: 読み取り専用
  gcePersistentDisk:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    partition:
      label: パーティション
      placeholder: "例: 1; 0 for entire device"
    pdName:
      label: 永続ディスク名
      placeholder: "例: abc"
    readOnly:
      label: 読み取り専用
  iscsi:
    chapAuthDiscovery:
      label: CHAP 認証ディスカバリー
    chapAuthSession:
      label: CHAP 認証セッション
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    initiatorName:
      label: イニシエーター名
      placeholder: "例: abc"
    iqn:
      label: IQN 番号
      placeholder: "例: 2"
    iscsiInterface:
      label: iSCSI インターフェース
      placeholder: "例: interface"
    lun:
      label: LUN 番号
      placeholder: "例: 2"
    portals:
      label: ポータル
      addActionLabel: 追加
    readOnly:
      label: 読み取り専用
    secretRef:
      label: シークレット
      placeholder: "例: secret"
    targetPortal:
      label: ターゲットポータル
      placeholder: "例: portal"
  local:
    path:
      label: パス
      placeholder: "例: / var"
  nfs:
    path:
      label: パス
      placeholder: "例: /var"
    readOnly:
      label: 読み取り専用
    server:
      label: サーバー
      placeholder: "例: 10.244.1.4"
  cinder:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    readOnly:
      label: 読み取り専用
    volumeID:
      label: ボリューム ID
      placeholder: "例: vol"
  photonPersistentDisk:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    pdID:
      label: PD ID
      placeholder: "例: abc"
  portworxVolume:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    readOnly:
      label: 読み取り専用
    volumeID:
      label: ボリューム ID
      placeholder: "例: abc"
  quobyte:
    group:
      label: グループ
      placeholder: "例: abc"
    readOnly:
      label: 読み取り専用
    registry:
      label: レジストリ
      placeholder: "例: abc"
    user:
      label: ユーザー
      placeholder: "例: root"
    volume:
      label: ボリューム
      placeholder: "例: vol"
  scaleIO:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    gateway:
      label: ゲートウェイ
      placeholder: "例: https://localhost:443/api"
    protectionDomain:
      label: 保護ドメイン
      placeholder: "例: pd01"
    readOnly:
      label: 読み取り専用
    secretRef:
      name:
        label: 名前
        placeholder: "例: secret"
      namespace:
        label: 名前空間
        placeholder: "例: default"
      label: シークレット
    sslEnabled:
      label: SSL 有効
    storageMode:
      label: ストレージモード
      placeholder: "例: ThinProvisioned"
    storagePool:
      label: ストレージプール
      placeholder: "例: sp01"
    system:
      label: システム
      placeholder: "例: scaleio"
    volumeName:
      label: ボリューム名
      placeholder: "例: vol-0"
  storageos:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    readOnly:
      label: 読み取り専用
    secretRef:
      name:
        label: 名前
        placeholder: "例: secret"
      namespace:
        label: 名前空間
        placeholder: "例: default"
      label: シークレット
    volumeName:
      label: ボリューム名
      placeholder: "例: vol"
    volumeNamespace:
      label: ボリューム名前空間
      placeholder: "例: default"
  vsphereVolume:
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    storagePolicyID:
      label: ストレージポリシー ID
      placeholder: "例: sp1"
    storagePolicyName:
      label: ストレージポリシー名
      placeholder: "例: sp"
    volumePath:
      label: ボリュームパス
      placeholder: "例: /"
cruStorageClass:
  name:
    placeholder: '例: storage'
  description:
    placeholder: '例: AWS EBS Storage'
  title:
    new: ストレージクラスを追加
    edit: 'ストレージクラスを編集: {name}'
    view: 'ストレージクラス: {name}'
  allowVolumeExpansion:
    label: ユーザーがボリュームを拡張することを許容
  pv:
    title: 永続ボリューム
  mountOptions:
    label: マウントオプション
    addActionLabel: オプションを追加
    noData: マウントオプションはありません
  parameters:
    title: パラメーター
    detail: ストレージクラスにプロバイダー固有のパラメーターを設定する
    addActionLabel: パラメーターを追加
  customize:
    title: カスタマイズ
    detail: 拡張オプションをカスタマイズ
  provisioner:
    label: プロビジョナー
  reclaimPolicy:
    label: 要求ポリシー
    Delete: ワークロードによって解放された時にボリュームとデバイスを削除
    Retain: 手動でクリーンアップされるまでボリュームを保持
    Recycle: "リサイクル: ボリュームの内容を空にし次回のワークロードで利用できるようボリュームを保持"
  aws-ebs:
    type:
      label: ボリュームタイプ
      gp2: 'GP2 - 汎用 SSD'
      io1: 'IO1 - プロビジョンド IOPS SSD'
      st1: 'ST1 - スループット最適化 HDD'
      sc1: 'SC1 - Cold-Storage HDD'
    zone:
      label: アベイラビリティゾーン
      automatic: "自動: クラスター内のノードがが存在しているゾーン"
      manual: "手動: 特定ゾーンを選択"
      placeholder: "us-east-1d, us-east-1c"
    iopsPerGB:
      label: プロビジョンド IOPS
      unit: 秒間, GB辺り
    encrypted:
      label: 暗号化
    kmsKeyId:
      label: 暗号化用 KMS キー ID
      automatic: "自動: キーを生成"
      manual: "手動: 特定のキーを利用(フル ARN)"
  gce-pd:
    type:
      label: ボリュームタイプ
      pd-standard: '標準'
      pd-ssd: 'SSD'
    zone:
      label: ゾーン
      automatic: "自動: クラスター内のノードがが存在しているゾーン"
      manual: "手動: 特定ゾーンを選択"
      placeholder: "us-central1-a, us-central1-b"
  cinder:
    type:
      label: ボリュームタイプ
      placeholder: "例: fast"
    availability:
      label: アベイラビリティゾーン
      automatic: "自動: クラスター内のノードがが存在しているゾーン"
      manual: "手動: 特定ゾーンを選択"
      placeholder: "例: nova"
  vsphere-volume:
    diskformat:
      label: ディスクフォーマット
      thin: シンプロビジョニング
      zeroedthick: シックプロビジョニング(Lazy Zeroed)
      eagerzeroedthick: シックプロビジョニング(Eager Zeroed)
    storagePolicyName:
      label: ストレージポリシー名
      placeholder: "例: gold"
    datastore:
      label: データストア
      placeholder: "例: VSANDatastore"
    fstype:
      label: ファイルシステムタイプ
      placeholder: "例: ext3"
    hostFailuresToTolerate:
      label: 許容するホスト障害回数
      placeholder: "例: 2"
    cachereservation:
      label: キャッシュ予約
      placeholder: "例: 20"
  azure-disk:
    new: 新しい Azure ディスク
    skuName:
      label: Sku 名
      placeholder: "例: Standard_LRS"
    location:
      label: ロケーション
      placeholder: "例: eastus"
    storageAccount:
      label: ストレージアカウント
      placeholder: "例: azure_storage_account_name"
    storageaccounttype:
      label: ストレージアカウントタイプ
      placeholder: "例: Standard_LRS"
    kind:
      label: 種類
      managed: マネージド
      placeholder: "例: Shared"
  azure-file:
    skuName:
      label: Sku 名
      placeholder: "例: Standard_LRS"
    location:
      label: ロケーション
      placeholder: "例: eastus"
    storageAccount:
      label: ストレージアカウント
      placeholder: "例: azure_storage_account_name"
  portworx-volume:
    fs:
      label: ファイルシステム
      placeholder: "例: ext4"
    block_size:
      label: ブロックサイズ
      placeholder: "例: 32"
    repl:
      label: レプリケーション
      placeholder: "例: 1; 0 for entire device"
    io_priority:
      label: I/O 優先度
      placeholder: "例: low"
    snap_interval:
      label: スナップショット間隔
      placeholder: "例: 70"
    aggregation_level:
      label: アグリゲーションレベル
      placeholder: "例: 0"
    ephemeral:
      label: エフェメラル
      placeholder: "例: true"
  scaleio:
    gateway:
      label: ゲートウェイ
      placeholder: "例: https://192.168.99.200:443/api"
    system:
      label: システム
      placeholder: "例: scaleio"
    protectionDomain:
      label: 保護ドメイン
      placeholder: "例: pd0"
    storagePool:
      label: ストレージプール
      placeholder: "例: sp1"
    storageMode:
      label: ストレージモード
      ThinProvisioned: シンプロビジョニング
      ThickProvisioned: シックプロビジョニング
    secretRef:
      label: 参照シークレット
      placeholder: "例: sio-secret"
    readOnly:
      label: 読み込み専用
      placeholder: "例: false"
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: xfs"
  storageos:
    pool:
      label: プール
      placeholder: "例: default"
    description:
      label: 詳細情報
      placeholder: "例: Kubernetes volume"
    adminSecretNamespace:
      label: 管理シークレット名前空間
      placeholder: "例: default"
    adminSecretName:
      label: 管理シークレット名
      placeholder: "例: storageos-secret"
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
  longhorn:
    numberOfReplicas:
      label: レプリカ数
      placeholder: "例: 3"
    staleReplicaTimeout:
      label: レプリカのタイムアウト値
      placeholder: "例 30"
  quobyte:
    quobyteAPIServer:
      label: Quobyte API サーバー
      placeholder: "例: http://138.68.74.142:7860"
    registry:
      label: レジストリ
      placeholder: "例: 138.68.74.142:7861"
    adminSecretNamespace:
      label: 管理シークレット名前空間
      placeholder: "例: kube-system"
    adminSecretName:
      label: 管理シークレット名
      placeholder: "例: quobyte-admin-secret"
    user:
      label: ユーザー
      placeholder: "例: root"
    group:
      label: グループ
      placeholder: "例: root"
    quobyteConfig:
      label: Quobyte コンフィグ
      placeholder: "例: BASE"
    quobyteTenant:
      label: Quobyte テナント
      placeholder: "例: DEFAULT"
  rbd:
    monitors:
      label: モニター
      placeholder: "例: 10.16.153.105:6789"
    adminId:
      label: 管理者 ID
      placeholder: "例: kube"
    adminSecretNamespace:
      label: 管理シークレット名前空間
      placeholder: "例: kube-system"
    adminSecretName:
      label: 管理シークレット
      placeholder: "例: secret"
    pool:
      label: プール
      placeholder: "例: kube"
    userId:
      label: ユーザー ID
      placeholder: "例: kube"
    userSecretName:
      label: ユーザーシークレット名
      placeholder: "例: ceph-secret-user"
    fsType:
      label: ファイルシステムタイプ
      placeholder: "例: ext4"
    imageFormat:
      label: イメージフォーマット
      placeholder: "例: 2"
    imageFeatures:
      label: イメージ機能
      placeholder: "例: layering"
  glusterfs:
    resturl:
      label: REST URL
      placeholder: "例: http://127.0.0.1:8081"
    restuser:
      label: REST ユーザー
      placeholder: "例: admin"
    restuserkey:
      label: REST ユーザーキー
      placeholder: "例: password"
    secretNamespace:
      label: シークレット名前空間
      placeholder: "例: default"
    secretName:
      label: シークレット名
      placeholder: "例: heketi-secret"
    clusterid:
      label: クラスター ID
      placeholder: "例: 630372ccdc720a92c681fb928f27b53f"
    gidMin:
      label: 最小 GID
      placeholder: "例: 40000"
    gidMax:
      label: 最大 GID
      placeholder: "例: 50000"
    volumetype:
      label: ボリュームタイプ
      placeholder: "例: replicate:3"
dangerZone:
  header: 拡張設定
  subtext: "一般的なユーザーの場合、これらを変更する必要はありません。間違った値を指定するとあなたの {appName} が壊れる可能性がありますので、慎重に進めてください。<br/>既定の値から変更された設定値は<b>太字</b>で表示されます。"
  showLabel: 私は拡張設定を変更することで問題が生じる可能性があると理解しています。
  description:
    'cacerts': "サーバー証明書を検証するために必要な CA証明書"
    'cluster-defaults': '新しいクラスターを作成するときにRKEのデフォルトを上書きします。'
    'engine-newest-version': 'このリリースにおける最新のサポートされる Docker バージョンです。サポートされる Docker バージョンより新しいバージョンを利用することも出来ますが未テストのマークが付きます。'
    'engine-supported-range': 'サポートされる Docker エンジンバージョンの範囲です。この範囲外のバージョンは UI 上で未サポートのマークが付きます。'
    'ui-index': 'UI 向けの HTML index ファイルの場所です'
    'ui-pl': 'プライベートブランド用の会社名です'
editAccount:
  title: アカウントを編集
  form:
    name:
      label: 表示名
      placeholder: '例: ジョン スミス'
    kind:
      label: アカウントタイプ
      user: ノーマルユーザー
      admin: "管理者：すべてのクラスタのすべてを管理するフルアクセス"
    description:
      label: 詳細情報
      placeholder: '例: このアカウントは、ジョン ・ スミス用です'
    publicValue:
      label: ユーザー名
    oldPassword:
      label: 現在のパスワード
    newPassword:
      label: 新しいパスワード
    confirmPassword:
      label: 新しいパスワード(確認用)
    identity:
      label: ID
editApiKey:
  title:
    justCreated: API Key は作成されました
    editing: API キーを編集
    new: API キーを追加
  accessKey: アクセスキー(username)
  secretKey: 秘密キー(password)
  basicAuth: "アクセスキーと秘密キーは HTTP ベーシック認証においてユーザー名とパスワードとして認証リクエストを送信できます。また、これらを結合し Bearer トークンとしても利用できます:"
  token: Bearer トークン
  ttl:
    label: 自動での失効日設定
    never: 失効しない
    day: 現在から 1 日
    month: 現在から 1 ヶ月
    year: 現在から 1 年
  description:
    placeholder: "オプション 例: このキーはアプリケーションサーバーでコンテナをデプロイするのに使われます"
  saveWarning1: 上記のキーを保存してください!  以降、秘密キーは参照できません。
  saveWarning2: もしキーを無くしてしまった場合、新しい API キーを作成する必要があります。
  noteOptional: 名前と詳細情報は何のために利用されるかを示すためのオプションです。 作成をクリックすることで単純に作成することもできます。
editCertificate:
  title: 証明書を編集
  name:
    placeholder: '例: mydomain.com'
  description:
    placeholder: '例: mydomain.com の EV 証明書'
  noteKeyWriteOnly: "注: プライベートキーは書き込み専用のためあえて空にしています。プライベートキーを変更する場合を除いて、これを入力する必要はありません。"
editCluster:
  title:
    new: クラスターを追加
    edit: クラスターを編集
  name:
    label: 名前
    placeholder: e.g. Sandbox
  description:
    label: 詳細情報
    placeholder: e.g. Shared cluster for development
  systemStacks:
    hr: クラスターオプション
    title: システムカタログスタック
    detail: これらのスタックはクラスタのシステム環境上に自動的にデプロイされます
    noData: システム環境にデプロイされるスタックはありません
    add: スタックを追加
    cancel: システムスタックの追加をキャンセル
  modal:
    onCluster: "重要: 現在の環境を所有するクラスターを削除しようとしています。このクラスターを削除する前に、別のクラスター内の新しい環境を選択してください"
editContainer:
  title:
    vm: VM を編集
    container: コンテナを編集
  name:
    placeholder: '例: myapp'
  description:
    placeholder: '例: マイアプリケーション'
editHost:
  title: ノードを編集
  hostname:
    label: ホスト名
    help: ノードのOSによって決定されます。
  customName:
    label: カスタム名
    placeholder: '例: dev1'
    help: 空の場合、ホスト名が表示されます。
  description:
    label: 詳細情報
    placeholder: '例: 私の開発用ノード'
  labels:
    label: ラベル
  ips:
    label: スケジューラ IP
    valueLabel: IP アドレス
    valuePlaceholder: '例: 1.2.3.4'
    addActionLabel: IP アドレスを追加
    help: 入力された場合、スケジューラが与えられたパブリック IP アドレス群から対象を選択し公開ポートをバインドします。
  requireAny:
    label: 必要となるコンテナラベル
    help: 指定した場合、このノードに適切にスケジューリングされるようコンテナは1つまたは複数のラベルを設定する必要があります。値を空のままにした場合一致するキーの有無に関わらずコンテナはスケジュールされます。システムコンテナをこのノードにスケジューリングするには<code>io.rancher.container.system</code> が必要となります。
    addActionLabel: 必要となるラベルを追加
editService:
  title: サービスを編集
editStack:
  title: 名前空間を編集
  name:
    label: 名前
    error: 名前空間の名前は既に使われています。新しい名前空間の名前を設定してください。
    placeholder: '例: myapp'
  project:
    label: プロジェクト
    prompt: プロジェクトを選択してください...
  description:
    label: 詳細情報
    placeholder: '例: MyApp 名前空間'
  resourceQuota:
    title: リソース制限
  group:
    label: タグ
    placeholder: '例: frontend, production'
    help: 新しいスタックのタグのカンマ区切りリスト。ワークロードの一覧は個々のタグでフィルタリングすることができます。
editUser:
  title: ユーザーの編集
  form:
    name:
      label: 表示名
      placeholder: '例: Taro Yamada'
    username:
      label: ユーザー名
    otherRoles:
      label: ロールを削除
    password:
      label: パスワードを変更
      new: 新しいパスワード
      confirm: 新しいパスワード(確認用)
      error: パスワードが一致しません
      mustChangePassword:
        new: 最初のログイン時にパスワードを変更するようユーザーに要求する
        edit: 次のログイン時にパスワードを変更するようユーザーに要求する
envCatalog:
  header: カタログ
  subtext: '独自のカスタムされたカタログソースを定義できます。カタログは、追加された環境下でのみ利用できます。それぞれのカタログには固有の名前と <code>git clone</code> 可能な URL が必要です。(詳細は <a href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a" target="_blank" rel="nofollow noopener noreferrer">docs</a> を参照してください)。'
  addActionLabel: カタログを追加
moveNamespace:
  title: |
    {count, plural,
    =1 {個の名前空間: {name}}
    other {# 個の名前空間}
    }の移動:
  to: "移動先のプロジェクト:"
  actionLabel: 移動
stackHeader:
  title: '名前空間: {name}'
  outputs: 出力
stacksPage:
  table:
    standalone: 独立型コンテナ
    endpoints: エンドポイント
    scale: スケール数
    instanceState: コンテナの状態
    instanceStateWithIcon: 状態
formatIp:
  noIp: None
formBalancerConfig:
  title: カスタムの設定ファイル
  detail: '{appName} によって生成された設定より上位に適用するためのカスタム設定ファイルを指定してください'
  custom: |
    ファイルに指定可能なオプションの詳細は <a href="https://cbonte.github.io/haproxy-dconv/1.6/configuration.html" target="_blank" rel="nofollow noopener noreferrer">haproxy ドキュメント</a> を参照してください。ターゲットコンテナの IP アドレスを含む <code>backend</code> や関連する行を上書きする際は <code>$IP</code> と指定することで {appName} が適切な行を生成します。
  config:
    prompt: カスタムされた haproxy.cfg の内容
formNodeAffinity:
  addRuleLabel: ノードセレクターを追加
  noRules: ノードセレクタはありません
  removeRuleLabel: ノードセレクタを削除
formNodeRequirement:
  label: ルール
  addRuleLabel: ルールを追加
  noRules: ルールはありません
  key:
    label: キー
  operator:
    label: オペレーター
  values:
    label: 値
    placeholder: コンマ区切り 例 node1,node2
formIngress:
  hostMode:
    manual: 使用するホスト名を指定する
    default: デフォルトのバックエンドとして使用
  defaultBackend:
    label: このルールをデフォルトのバックエンドとして設定する
    mark: デフォルトのバックエンド
  label: ルール
  addRuleLabel: ルールを追加
  removeRuleLabel: このルールを削除
  noRules: ルールはありません
  host:
    label: リクエストホスト
    placeholder: "例: example.com"
  backendType:
    label: バックエンドタイプ
  mode:
    workload: ワークロード
    service: DNS レコード
formIngressBackends:
  label: ターゲットバックエンド
  noRules: バックエンドはありません。
  addServiceLabel: サービスを追加
  addWorkloadLabel: ワークロードを追加
  service:
    label: サービス
  workload:
    label: ワークロード
  targetPort:
    label: ポート
    placeholder: '例: 80'
  path:
    label: パス
    placeholder: '例: /foo'
  target: ターゲット
formBalancerListeners:
  label: リスナー & ターゲットルール
  detail: バランサーに入ってくるリクエストを目的のターゲットにマッピングするよう制御します。
  status: |
    {count, plural,
    =0 {ルールはありません}
    =1 {# ルール}
    other {# ルール}
    }
  noRules: ルールはありません
  addPortLabel: リスニングポートを追加
  removePortLabel: このリスニングポートを削除
  showBackendLabel: "バックエンド名をカスタマイズ"
  access:
    label: アクセス
    public: パブリック
    internal: インターナル
  protocol:
    label: プロトコル
  sourceIp:
    label: ホスト IP
    placeholder: "例: 1.2.3.4; デフォルト: All"
  sourcePort:
    label: リスニングポート
    placeholder: '例: 80'
  help: "ホストとパスルールは表示順の上部から下部に向かって評価されます。バックエンドはデフォルトではランダムの名前がつけられ、生成されるバックエンド名をカスタマイズする場合は名前を付与することでカスタマイズされた haproxy.cfg 内部で指定した名前を参照します。"
formBalancerRules:
  label: ターゲットルール
  detail: ホストまたはポート、パス、IPアドレスに応じて、異なるターゲットにリクエストをマップします。
  status: |
    {count, plural,
    =0 {ルールはありません}
    =1 {# ルール}
    other {# ルール}
    }
  noRules: ルールはありません
  addServiceLabel: サービスを追加
  addInstanceLabel: コンテナを追加
  addSelectorLabel: セレクターを追加
  addTargetLabel: ルールを追加
  access:
    label: アクセス
    public: パブリック
    internal: 内部
  protocol:
    label: プロトコル
  sourceIp:
    label: ホスト IP
    placeholder: "例: 1.2.3.4; デフォルト: All"
  sourcePort:
    label: リッスンポート
    placeholder: '例: 80'
  path:
    label: パス
    placeholder: '例: /foo'
  hostname:
    label: リクエストホスト
    placeholder: '例: example.com'
  backendName:
    label: バックエンド
    placeholder: '例: webapp'
  targetPort:
    label: ポート
    placeholder: '例: 80'
  priority:
    label: 優先度
  target: 対象
  selector:
    label: セレクタ
    placeholder: '例: foo=bar'
formCommand:
  title: コマンド
  detail: コンテナ起動時に実行されるコマンドを設定します
  command:
    label: コマンド
    placeholder: '例: /usr/sbin/httpd -f httpd.conf'
  entryPoint:
    label: エントリーポイント
    placeholder: '例: /bin/sh'
  environment:
    label: 環境ラベル
  workingDir:
    label: ワーキングディレクトリ
    placeholder: '例: /myapp'
  uid:
    label: ユーザー ID
    placeholder: '例: 501'
  console:
    label: コンソール
    both: 'インタラクティブ &amp; TTY <span class="text-muted">(-i -t)</span>'
    interactive: 'インタラクティブ <span class="text-muted">(-i)</span>'
    terminal: 'TTY <span class="text-muted">(-t)</span>'
    none: None
  autoRestart:
    label: 自動リスタート
    no: しない
    onFailure: '失敗時 <span class="text-muted">(0 でない終了コード)</span>, 再起動し続ける'
    onFailureCondPrefix: 失敗時に
    onFailureCondSuffix: |
      {limit, plural,
      =1 {回}
      other {回}
      }再起動
    always: 常に
  terminationGracePeriodSeconds:
    label: タイムアウトを停止
    helpText: コンテナは、強制的に終了される前に、これだけの時間だけ停止します。
  fsgid:
    label: ファイルシステムグループ
    placeholder: '例: 501'
formContainerLinks:
  title: リンク
  detail: このコンテナと他のコンテナーの関係性を定義します
  addActionLabel: リンクを追加
  name:
    label: 対象コンテナ
  alias:
    label: エイリアス名
    placeholder: '例: database'
  noData: コンテナリンクはありません
  noMatch: 検索条件に一致するリンクがありません
formCount:
  label: 数
formDisks:
  addDiskLabel: ディスクを追加
  addRootDiskLabel: ルートディスクを追加
  name:
    rootDisk: ルートディスク
    label: 名前
    placeholder: '例: data'
  size:
    label: サイズ
    rootDisk: ルートイメージによって決まります
  readIops:
    label: 読み込み IOPS
    placeholder: '例: 1000'
  writeIops:
    label: 書き込み IOPS
    placeholder: '例: 1000'
  driver:
    label: ドライバー
formEngineOpts:
  title: エンジンオプション
  detail: Docker デーモンの設定をカスタマイズします
  engineInstallUrl:
    label: Docker インストール URL
    placeholder: '例: http://get.docker.com/'
    recommended: 推奨
    latest: 最新
  engineStorageDriver:
    label: ストレージドライバー
    placeholder: '例: overlay'
  engineOpts:
    label: エンジンオプション
    addActionLabel: エンジンオプションを追加
    keyPlaceholder: '例: log-driver'
    valuePlaceholder: '例: syslog'
  engineLabels:
    label: エンジンラベル
    addActionLabel: エンジンラベルを追加
    keyLabel: ラベル
  engineEnv:
    label: エンジン環境変数
    addActionLabel: 環境変数を追加
    keyLabel: 変数
    keyPlaceholder: '例: HTTP_PROXY'
    valuePlaceholder: '例: http://your-proxy:8080'
  engineInsecureRegistry:
    label: インセキュアレジストリ
    addActionLabel: インセキュアレジストリを追加
    valueLabel: レジストリドメイン
    valuePlaceholder: '例: registry.example.com'
  engineRegistryMirror:
    label: レジストリミラー
    addActionLabel: レジストリミラーを追加
    valueLabel: ミラー URL
    valuePlaceholder: '例: https://my-mirror.example.com:5000'
formResourceQuota:
  table:
    type:
      label: リソースタイプ
    value:
      label: 制限
      placeholder: '例: 10'
      milliCpuPlaceholder: '例: 500'
      memoryPlaceholder: '例: 1Gi'
    projectLimit:
      placeholder: '例: 50'
      milliCpuPlaceholder: '例: 2000'
      memoryPlaceholder: '例: 2048'
    namespaceLimit:
      placeholder: '例: 10'
      milliCpuPlaceholder: '例: 500'
      memoryPlaceholder: '例: 1024'
  errors:
    limitRequired: '{resource} が必要です.'
  resources:
    configMaps: コンフィグマップ
    limitsCpu: CPU 制限
    limitsMemory: メモリ制限
    persistentVolumeClaims: 永続ボリューム要求
    pods: ポッド
    replicationControllers: レプリケーションコントローラー
    requestsCpu: CPU 予約
    requestsMemory: メモリ予約
    requestsStorage: ストレージ予約
    secrets: シークレット
    services: サービス
    servicesLoadBalancers: サービスロードバランサ
    servicesNodePorts: サービスノードポート
formEnvVar:
  title: 環境変数
  detail: 作成時に追加された環境変数
  noData: 環境変数はありません
  status: |
    {count, plural,
    =0 {設定されていません}
    =1 {# 変数}
    other {# 変数}
    }
  labels:
    key: キー
    value: 値
formGlobalRoles:
  title: グローバル権限
  description: ユーザーが {appName} 環境全体を管理する際に必要なアクセス権を制御します
  mode:
    admin:
      label: 管理者
      detail: 管理者は、環境全体およびすべてのクラスタ内のすべてのリソースを完全に制御できます
    user:
      label: 一般ユーザー
      detail: 一般ユーザーは、新しいクラスターを作成しアクセスが許可されているクラスターおよびプロジェクトを管理できます
    custom:
      label: カスタム
      detail: ユーザー個別のアクセス許可を選択します
  role:
    create-clusters:
      label: 新しいクラスタの作成
      detail: ユーザーが新しいクラスターを作成し、そのクラスターの所有者になることを許可します。一般ユーザーは、デフォルトでこのアクセス許可を持っています。
    manage-authn:
      label: 認証の設定
      detail: ユーザーがすべての認証プロバイダ設定を有効化、設定、および無効化できるようにします
    manage-catalogs:
      label: カタログの設定
      detail: ユーザーがカタログを追加、編集、および削除できるようにします
    manage-clusters:
      label: 全てのクラスタの管理
      detail: ユーザーがメンバーとして所属していないクラスタを含め、すべてのクラスタを管理できるようにします
    manage-node-drivers:
      label: ノードドライバーの設定
      detail: ユーザーがすべてのノードドライバー設定を有効化、設定、および削除できるようにします
    manage-node-templates:
      label: ノードテンプレートの管理
      detail: ユーザーがノードテンプレートを定義、編集、および削除できるようにします
    manage-roles:
      label: ロールの管理
      detail: ユーザーがロールを定義、編集、および削除できるようにします
    manage-users:
      label: ユーザーの管理
      detail: ユーザーがすべてのユーザーの作成、削除、およびパスワードの設定をできるようにします
    use-catalogs:
      label: カタログの利用
      detail: ユーザーがカタログからテンプレートを表示およびデプロイできるようにします。一般ユーザーはデフォルトでこのアクセス許可を持っています。
    use-node-templates:
      label: ノードテンプレートの利用
      detail: ユーザーが既存のノードテンプレートを使用して新しいノードをデプロイできるようにします
    base:
      label: ログインアクセス
formMembers:
  members:
    user: ユーザー
    group: グループ
    serviceaccount: サービスアカウント
    labelText: メンバー
    addMember: メンバーを追加
    addUser: ユーザーを追加
    noAddUser: あなたが唯一のアクティブな登録済みユーザーです
    addGroup: グループを追加
    addServiceAccount: サービスアカウントを追加
    multipleRoles: 複数ロール
    customRoles: カスタムロール
    kind:
      label: 種類
    name:
      label: 名前
    role:
      label: ロール
    errors:
      nameReq: 名前が必要です
      nameInExists: 名前は既に存在しています。新しいプロジェクト名を使用してください。
      memberNameReq: メンバーには名前が必要です
      memberRoleReq: メンバーにはロールが必要です
      ownerReq: 少なくとも1人オーナーロールのメンバーが必要です
formScopedRoles:
  title: '{type} 権限'
  description: '{type} に対するユーザーのアクセス権を制御します'
  mode:
    admin:
      label: オーナー
      detail: オーナーは {type} とその内部のリソースに対してフルコントロール権限を持ちます
    user:
      label: メンバー
      detail: メンバーは {type} の内部リソースに対して管理権限を持ちますが {type} 自体の変更はできません
    custom:
      label: カスタム
      detail: このユーザーのロールを選択します。
    readOnly:
      label: 読み取り専用
      detail: メンバーは {type} の内部リソースを参照することはできますが {type} 自体の変更はできません
    userDef:
      detail: ユーザー定義のロール
    role:
      read-only:
        label: 読み取り専用
        detail: すべてを閲覧することができますが、変更は行えません。
formHealthCheck:
  title: ヘルスチェック
  detail: 定期的にコンテナへリクエストを送り、コンテナが生存していて正しく応答するかどうかを確認します。
  readiness: 準備確認
  liveness: ライフチェック
  separateLivenessCheck: 個別の liveness チェックを定義
  combinedLivenessCheck: liveness と readiness に同様のチェックを利用
  checkType:
    none: None
    tcp: TCP 接続が正常にオープンしているか確認
    http: HTTP リクエストに対し成功が返ってくるか確認 (2xx または 3xx)
    https: HTTPS リクエストに対し成功が返ってくるか確認 (2xx または 3xx)
    command: コンテナ内でコマンドを実行し 0 が返ってくるか確認
  command:
    label: コマンド
    placeholder: '例: cat /tmp/health'
  path:
    label: リクエストパス
    placeholder: '例: /healthcheck'
  httpHeaders:
    label: 追加ヘッダー
    addActionLabel: ヘッダーを追加
    keyLabel: ヘッダー名
    keyPlaceholder: '例: ユーザーエージェント'
    valuePlaceholder: '例: ヘルスチェック'
  host:
    label: ホストヘッダー
    placeholder: '例: example.com'
  port:
    label: 対象コンテナポート
    placeholder: '例: 80'
  initialDelaySeconds:
    label: チェック開始タイミング
  reinitializingTimeout:
    label: 再初期化タイムアウト
  periodSeconds:
    label: チェック間隔
  timeoutSeconds:
    label: チェックタイムアウト
  successThreshold:
    label: 正常とする回数
    unit: 成功
  failureThreshold:
    label: 不健全とする回数
    unit: 失敗
formKeyToPath:
  addAction: アイテムを追加
  header: アイテム
  default: 全てのキー
  specific: 特定のキーを選択してください
  key:
    label: キー
    placeholder: "例: username"
  path:
    label: パス
    placeholder: "例: my-group/my-username"
  mode:
    label: モード
    placeholder: "例: 400"
formKeyValue:
  addAction: ペアを追加
  key:
    label: キー
    placeholder: キー
  separator: "="
  value:
    label: 値
    placeholder: 値
  protip: 'ProTip: 簡単に入力するには key=value ペアをペーストしてください。'
formImage:
  label: Docker イメージ
  container:
    placeholder: "例: ubuntu:xenial"
formNameDescription:
  name:
    label: 名前
    placeholder: 名前
  description:
    label: 詳細情報
    placeholder: 詳細情報
    expand: 詳細情報を追加
formNetwork:
  title: ネットワーク
  detail: コンテナに対しネットワークと DNS オプションを設定します
  netMode:
    label: ホストのネットワーク名前空間を使用する
    disable: "いいえ"
    enable: "はい"
  dnsPolicy:
    label: DNS ポリシー
    clusterFirstWithHostNet: "Cluster first with host network"
    clusterFirst: "Cluster first"
  container:
    label: コンテナ
  requestedIp:
    label: リクエスト IP
    placeholder: 'オプション; 例: 10.42.2.24'
    help: 10.42.0.0/16 ブロックから特定の IP を指定します。既に利用されている場合ランダムな IP が割り当てられます。
  retainIp:
    label: 保有 IP
    reuse: アップグレード時に既存の IP を再利用または置換
  dns:
    label: サービスディスカバリ
    enable: ディスカバリを有効にしてローカルのリゾルバー キャッシュを使用
    disable: ディスカバリを無効にし、直接リモートの名前解決サーバーを使用
  hostname:
    label: ホスト名
    placeholder: '例: web'
    dockerId: Docker コンテナ ID を使う
    hostName: 起動するホストのホスト名を利用する
    containerName: コンテナ名を使う
    custom: 特定のホスト名を設定
  domainName:
    label: ドメイン名
    placeholder: '例: example.com'
  resolvingServers:
    label: DNS サーバー
    addActionLabel: サーバーを追加
    placeholder: '例: 8.8.4.4'
  searchDomains:
    label: サーチドメイン
    placeholder: '例: prod.example.com'
    addActionLabel: ドメインを追加
  subdomain:
    label: サブドメイン
    placeholder: '例: foo'
  hostAlias:
    addActionLabel: ホストエイリアスを追加
    label: ホストエイリアス (/etc/hosts エントリー)
    host:
      label: ホスト名
      placeholder: '例: database'
    ip:
      label: IP アドレス
      placeholder: '例: 192.168.0.1'
formPorts:
  header: ポートマッピング
  addAction: ポートを追加
  kind:
    label: As a
    NodePort: ノードポート(全てのノード上)
    HostPort: ホストポート(ポッドが稼働しているノード)
    ClusterIP: クラスター IP(内部のみ)
    LoadBalancer: L4 ロードバランサー
  sourcePort:
    label: リッスンポート
    placeholder: "例: 80"
    ipPlaceholder: "例: 80 または 19.82.2.24:80"
    clusterIpDefault: "コンテナポートと同様"
  nodePort:
    placeholder: "デフォルトのノードポートの範囲は、30000-32767です。例 30000"
    customPortRangePlaceholder: "ノードポートの範囲は、{range} です。例 {port}"
  containerPort:
    label: コンテナポートを公開
    placeholder: "例: 8080"
  protocol:
    label: プロトコル
  name:
    label: 名前
    placeholder: "例: backend"
  dnsName:
    label: DNS 名
    placeholder: "例: example"
  noPorts: このコンテナにはポートマップがありません
  error:
    privateRequired: 各ポートルールにはプライベートコンテナ ポートが必要になります。
    publicRequired: ホスト IP を指定した場合はソースポートを指定する必要があります
    hostPort:
      sourcePortRequired: ポッドが稼働しているノードに対してはソースポートが必要になります
    loadBalancer:
      sourcePortRequired: ロードバランサーにはソースポートが必要になります
    mixedIpPort: "ポート {ip}:{port}/{proto} は、1 つ以上のマッピングを保持しています。"
    mixedPort: "ポート {port}/{proto} は、1 つ以上のマッピングを保持しています。"
  showAdvanced: ポート名オプションを見る
formScale:
  label: ワークロードタイプ
  showAdvanced: 詳細オプションを表示
  scaleMode:
    deploymentPrefix: "スケーラブルデプロイメント:"
    replicationControllerPrefix: "レプリケーションコントローラー:"
    replicaSetPrefix: "レプリカセット:"
    statefulSetPrefix: "ステートフルセット:"
    scaleSuffix: |
      {scale, plural,
      =1 {ポッド}
      other {ポッド}
      }
    daemonSet: "各ノード上で単一のポッドを実行"
    cronJob: "クーロンスケジュールとして動作"
    job: ジョブ
    sidekickInactive: "サイドカー: 既存ワークロードにコンテナを追加する"
    sidekickPrefix: "サイドカー: 次のワークロードにコンテナを追加"
formScheduling:
  title: ノード スケジューリング
  detail: ポッドがどのノード上でデプロイされるかを設定します。
  status: |
    {count, plural,
    =0 {ルールはありません}
    =1 {# ルール}
    other {# ルール}
    }
  canRequestHost:
    vm: <b>すべて</b> の仮想マシンを特定のノード上で起動する
    containers: このワークロード用のポッドを <b>全て</b> 特定ノード上で起動
  runSpecific: 特定のノードでこのポッドを実行する
  noRules: ルールはありません。
  noToleration: トレランスはありません
  autoRun: "スケジューリングルールにマッチした全てのノード上で自動的に起動:"
  autoPick:
    vm: "全ての仮想マシンに対しスケジューリングルールにマッチしたノードを自動的に選択:"
    container: "全てのポッドに対しスケジューリングルールにマッチしたノードを自動的に選択:"
    host: "スケジューリングルールにマッチしたノードを自動的に選択:"
  addRule: ルールを追加
  addCustom: カスタムルールを追加
  condition: 条件
  field: フィールド
  key: ラベルキー
  value: 値
  operator: オペレーター
  effect: 効果
  time: 時間
  toleration:
    title: トレランス
    add: トレランスを追加
  scaling:
    minMaxDetail: 設定することでユーザー操作や API 呼び出しによるスケーリング時に制限を設けられます
    incrementDetail: 設定することでスケール時に複数台ずつ増加されます
    hostMaxDetail: 設定されている場合は、このサービスのコンテナをこのほすとの最大数にスケジュールします。
  scaleMin: 最小スケール
  scaleMax: 最大スケール
  scaleIncrement: 増加数
  hostMax: 最大ノード数
  perHost: ホスト毎に
  priority:
    label: 優先度
    placeholder: '例: 3'
  priorityClassName:
    label: 優先クラス名
    placeholder: '例: 高い'
  scheduler:
    label: スケジューラー
    placeholder: '例: 私のスケジューラー'
  nodeSelector:
    operator:
      lt: '<'
      le: |
        &le;
      eq: '='
      ne: |
        &ne;
      gt: '>'
      ge: |
        &ge;
      in: 'in list'
      notIn: 'not in list'
      exists: 'is set'
      notExists: 'is not set'
    multiple:
      placeholder: '例: foo, bar, baz'
    custom:
      placeholder: '例: foo > 42 && bar != baz'
formSources:
  addLabel: ソースを追加
  type:
    label: タイプ
  source:
    label: ソース
  prefixOrKey:
    label: キー
  prefix:
    label: プリフィックスまたはエイリアス
formSecurity:
  title: セキュリティ & ホスト設定
  detail: 動作するホスト上でのコンテナのリソース保証または制限を設定します
  pullImage:
    label: イメージの取得
    always: 常に
    ifNotPresent: ホストに存在しない場合のみ
  privileged:
    label: 特権モード
    disable: "いいえ"
    enable: "はい: コンテナはホストに対してフルアクセス権限を持ちます"
  allowPrivilegeEscalation:
    label: 権限昇格
    disable: "いいえ"
    enable: "はい: コンテナは親プロセスよりも多くの権限を取得できます"
  hostIPC:
    label: ホストの IPC 名前空間を利用
  runAsNonRoot:
    label: 非rootとして起動
    disable: "いいえ"
    enable: "はい: コンテナは非rootのユーザーとして実行する必要があります"
  readOnlyRootFilesystem:
    label: 読み取り専用ルートファイルシステム
    disable: "いいえ"
    enable: "はい: コンテナは読み取り専用のルートファイルシステムを持ちます"
  hostPID:
    label: ホストの PID 名前空間を利用
  memoryLimit:
    label: メモリ制限
    unlimited: 無制限
    set: 制限値
  cpuLimit:
    label: CPU 制限
    unlimited: 無制限
    set: 制限
    unit: ミリ CPUs
  swapLimit:
    label: メモリスワップ
    unlimited: 無制限
    set: 制限値
    default: 物理制限値の 2 倍に制限
    none: スワップを許可しない
  swappiness:
    label: スワップ値
    default: ホストのデフォルトを使用する
    none: 最小
    set: カスタム (1-100)
  cpuPinning:
    label: CPU ピンニング
    placeholder: "例: 0,1,3; デフォルト: All"
  shares:
    label: CPU シェア
    placeholder: '例: 1024'
  capabilities:
    add: 追加ケーパビリティ
    drop: ドロップケーパビリティ
    helpBlock:
      text: ケーパビリティはコンテナ上で利用可能なスーパーユーザー権限で提供されるコントロール制御です
      link: 詳細を見る
  deviceBinding:
    label: デバイスバインディング
    addActionLabel: バインディングを追加
    pathHost:
      label: ホスト上のパス
      placeholder: '例: /dev/sdc'
    pathContainer:
      label: コンテナ上のパス
      placeholder: '例: /dev/xsdc'
    permissions:
      label: 権限
  memoryReservation:
    label: メモリ予約
    placeholder: '例: 128'
  milliCpuReservation:
    label: CPU 予約
    placeholder: '例: 1000'
    unit: ミリ CPUs
  gpuReservation:
    label: NVIDIA GPU 予約
    placeholder: '例: 1'
    unit: GPUs
  isolation:
    label: 分離
    default: デフォルト(コンテナ)
    hyperv: HyperV (VM)
formSslTermination:
  title: SSL/TLS 証明書
  detail: 暗号化されたポートへのリクエストに対し提示される証明書を設定します
  defaultCertificate:
    prompt: 証明書を選択してください...
  alternateCertificate:
    prompt: 証明書を選択してください...
  certificate: 証明書
  alternateCerts: 代替証明書
  addAlternate: 代替証明書を追加
  noCertificates: 利用可能な証明書はありません
  noCertificatesConfiged: 証明書はありません。
  noAlternateCertificates: 他の利用可能な証明書はありません。
  hosts: ホスト
  noHosts: ホストはありません
  host:
    label: ホスト
    placeholder: '例: example.com'
  addHostLabel: ホストを追加
  helpBlock: |
    "注: いくつかの古い SSL/TLS クライアントは <a href="https://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank">Server Name Indication (SNI)</a> をサポートしていません。これらのクライアントでは常にメイン証明書の提示を求められますが、比較的新しいクライアントでは一致するものが見つかると代替証明書のリストから適切な証明書を求めてきます。"
  notNeeded: 有効なターゲットルールで構成された SSL/TLS リッスンポートはありません
  removeCertLabel: この証明書を削除する
  addCertLabel: 証明書を追加
formNamespace:
  label:
    reuse: 名前空間
    create: 名前空間
    default: デフォルト名前空間
  toggle:
    simple: カスタマイズ
    reuse: 既存の名前空間を使用する
    create: 新しい名前空間を追加
  reuse:
    prompt: 名前空間を選択してください...
  create:
    placeholder: '例: 私のアプリ'
  errors:
    noneChosen: 名前空間を選択する必要があります
    validation: "名前空間: {error}"
formUserData:
  placeholder: "e.g. コンテナ用設定情報"
  isVmPlaceholder: "e.g. 仮想マシン用設定情報"
formLabelsAnnotations:
  title: ラベル & アノテーション
  detail: コンテナ用のラベル/アノテーションに利用されるキー/バリューペアを指定し、スケジューリングを決定します
formUserLabels:
  title: ラベル
  detail: ラベルはコンテナに注釈を付与しスケジューリングの決定に利用されるキー/値のペアです
  nodeDetail: ラベルはノードに適用されコンテナのスケジューリングの決定に利用されるキー/値のペアです
  addAction: ラベルを追加
  key:
    label: キー
    placeholder: '例: foo'
  separator: "="
  value:
    label: 値
    placeholder: '例: bar'
  protip: "ProTip: 簡単に入力するには1行以上の key=value ペアをペースト>してください。"
formAccessModes:
  label: アクセスモード
  accessRWO: 単一ノード読み取り/書き込み
  accessROX: 複数ノード読み取り専用
  accessRWX: 複数ノード読み取り/書き込み
formAnnotations:
  addActionLabel: アノテーションを追加
  title: アノテーション
  detail: コンテナのアノテーション(キー/値メタデータ) を設定します。
  errors:
    invalidJSON: アノテーションのJSONフォーマットが無効です。
    topLevelValueInvalid: アノテーションJSONのトップレベル値はオブジェクトでなければなりません。
formJobConfig:
  completions:
    label: 完了
formUpgrade:
  title: スケーリング/アップグレード ポリシー
  detail: アップグレードを実行した際のポッドの置換方法を設定します
  strategy:
    label: アップグレードストラテジー
    orderedReady: 厳密な順次アップデートを行い、準備が完了するのを待機
    parallel: 全てのポッドを作成後、古いポッドを並列で削除
    onDelete: アップグレード後のポッドのみ起動し、古いポッドは手動で削除
    recreate: 全てのポッドを削除後、新しいポッドを作成
    rollingUpdate: ローリングアップグレード
    startFirst: 'ローリング: 新しいポッドを起動後、古いポッドを停止'
    stopFirst: 'ローリング: 古いポッドを停止後、新しいポッドを起動'
    custom: カスタム
    batchSize:
      label: バッチサイズ
      detail: 指定された回数だけポッドは起動、停止します
    maxSurge:
      label: 最大サージ
      detail: 必要なポッドの数を超えて作成できるポッドの最大数です
    maxUnavailable:
      label: 最大利用不可数
      detail: 与えられた時間内で利用不可状態を許容する最大のポッド数
    minReadySeconds:
      label: 最小準備時間
      detail: ポッド内のコンテナは、ポッドが利用可能とみなされる前に少なくともこの期間は稼動していなければなりません
    progressDeadlineSeconds:
      label: 進行期限
      detail: 停滞しているデプロイメントをマークするまでにに進行状況を見ることがなく待機する時間
formValueArray:
  addActionLabel: 値を追加
  valueLabel: 値
  valuePlaceholder: 値
  noData: データはありません
  protip: "ProTip: 簡単に入力するには1行以上の値をペーストしてください。"
formVolumeRow:
  prompt: 永続ボリューム要求を選択してください...
  name:
    label: ボリューム名
    placeholder: '例: vol1'
  mode:
    label: ボリュームタイプ
    newVolume: エフェメラルボリューム
    existingVolume: 既存ボリューム
    newPvc: 新規ボリューム要求
    existingPvc: 永続ボリューム要求
    bindMount: バインド
    tmpfs: Tmpfs
    secret: シークレット
    configmap: コンフィグマップ
    certificate: 証明書
  remove: ボリュームを削除
  subPath: ボリューム内サブパス
  readOnly: 読み取り専用
  noVolume: ボリュームは現在のコンテナにマウントされません。ポッド内の他のコンテナで使用することができます。
  addMount: マウントを追加
  mounts:
    mountPoint: マウントポイント
    subPath: ボリューム内サブパス
    readOnly: 読み取り専用
    helper: ボリュームは現在のコンテナにマウントされません。ポッド内の他のコンテナで使用することができます。
  customLogPath:
    helpText: Flexvolume ドライバーを配備してボリュームを作成し、そのログをホストにマウントします。この機能は現在 GKE クラスターでサポートされています。
formVolumes:
  title: ボリューム
  detail: 個々のコンテナのライフサイクルから分離され、永続化やデータ共有に利用されます
  value:
    prompt: コンテナを選択してください...
  volumes: ボリューム
  volumesFrom: 他コンテナのボリューム
  volumeDriver:
    label: カスタムボリューム用のドライバ
    placeholder: '例: rancher-nfs; デフォルト: local'
    suggestion: '使用中のボリュームドライバー:'
  noLaunchConfigs: このサービスにはボリュームを共有するための起動設定がありません。
  noHostContainers: このホストには他コンテナのボリュームを利用するためのコンテナがありません。
  onlySingleHost: 特定ホストにコンテナを追加した場合のみ利用できます
  errors:
    incomplete: 不完全なボリューム定義
    absoluteMountPoint: ボリュームマウントポイントは絶対パスでなければなりません
  add:
    label: ボリュームを追加...
    newVolume: エフェメラルボリュームを追加
    existingVolume: 既存エフェメラルボリューム
    newPvc: 新しい永続ボリューム(要求)を作成
    existingPvc: 既存の永続ボリューム(要求)を使用
    bindMount: ノードからディレクトリをバインド
    tmpfs: インメモリtmpfsを追加
    secret: シークレットを使用
    configMap: コンフィグマップを使用
    certificate: ユーザー証明書
    customLogPath: ディレクトリからログファイルを読み込み
  table:
    kind: 種類
    source: ソース
    mountPoint: マウントポイント
    opts: アクセス/オプション
formCapabilityPodSecurityPolicy:
  title: ケーパビリティポリシー
  detail: ケーパビリティポリシーに関する設定です
  capabilities:
    allow: 許可されたケーパビリティ
    add: デフォルトで追加されるケーパビリティ
    drop: ドロップされるべきケーパビリティ
formVolumePodSecurityPolicy:
  title: ボリュームポリシー
  detail: 利用可能なボリュームタイプを制御します
  volumes: ボリューム
formAllowedHostPathsPodSecurityPolicy:
  title: 許可されたホストパスポリシー
  detail: 許可されたホストパスのホワイトリストです
  path:
    addLabel: パスプリフィックスを追加
    placeholder: '例: /foo'
formFsGroupPodSecurityPolicy:
  title: FS グループポリシー
  detail: ポッドのボリュームを所有する FS グループを割り当てます
  rule:
    mustRunAs: MustRunAs  - 少なくとも1つの範囲を指定する必要があります。最初の範囲の最小値をデフォルト値として使用します。最初の範囲の最初のIDに対して検証します。
    runAsAny: RunAsAny  - デフォルトはありません。任意の fsGroup ID を指定できます。
  range:
    addLabel: 範囲を追加
    max:
      label: 最大
      placeholder: '例: 6'
    min:
      label: 最小
      placeholder: '例: 1'
formHostPortsPodSecurityPolicy:
  title: ホストポートポリシー
  detail: 使用するホストポートを設定します
  port:
    addLabel: ポート範囲を追加
    max:
      label: 最大
      placeholder: '例: 7000'
    min:
      label: 最小
      placeholder: '例: 6000'
formRunAsUserPodSecurityPolicy:
  title: ユーザー実行ポリシー
  detail: ユーザーID
  rule:
    mustRunAs: MustRunAs - 少なくとも1つの範囲を設定する必要があります。範囲の最初の値をデフォルト値として使用します。検証は設定された範囲に対して行われます。
    mustRunAsNonRoot: MustRunAsNonRoot - ポッドにrunAsUserが0以外で提出されるか、USERディレクティブがイメージ内で定義されている必要があります。デフォルトは提供されていません。
    runAsAny: RunAsAny - デフォルトはありません。任意の runAsUser を指定できます。
  range:
    addLabel: 範囲を追加
    max:
      label: 最大
      placeholder: '例: 6'
    min:
      label: 最小
      placeholder: '例: 1'
formSeLinuxodSecurityPolicy:
  title: SELinux ポリシー
  detail: コンテナに対する SELinux コンテキストを設定します
  rule:
    mustRunAs: MustRunAs - デフォルトとしてseLinuxOptionsを使用します。検証は seLinuxOptions に対して行います。
    runAsAny: RunAsAny - 任意の seLinuxOptions を指定できるようにする
  level:
    label: レベル
    placeholder: '例: level'
  role:
    label: ロール
    placeholder: '例: role'
  user:
    label: ユーザー
    placeholder: '例: user'
formSupplementalGroupsPodSecurityPolicy:
  title: 補足のグループポリシー
  detail: 許容される補足的なグループポリシーを設定します
  rule:
    mustRunAs: MustRunAs - 少なくとも1つの範囲を指定する必要があります。最初の範囲の最小値をデフォルト値として使用します。すべての範囲のIDに対して検証します。
    runAsAny: RunAsAny - デフォルトはありません。任意の supplementalGroups を指定できます。
  range:
    addLabel: 範囲を追加
    max:
      label: 最大
      placeholder: '例: 6'
    min:
      label: 最小
      placeholder: '例: 1'
formBasicPodSecurityPolicy:
  title: 基本ポリシー
  detail: 基本的なポッドセキュリティポリシーに関する設定です
  allowPrivilegeEscalation:
    label: 権限昇格を許可する
    enable: "はい: コンテナの実行時に親からの権限昇格を許可します"
    disable: "いいえ"
  defaultAllowPrivilegeEscalation:
    label: デフォルトの権限昇格を許可する
    enable: "はい: プロセスが親プロセスより多くの権限を取得できるかどうかを制御します"
    disable: "いいえ"
  hostIPC:
    label: ホスト IPC
    enable: "はい: ホストの IPC 名前空間を使用します"
    disable: "いいえ"
  hostNetwork:
    label: ホストネットワーク
    enable: "はい: ホストネットワーキングを使用します"
    disable: "いいえ"
  hostPID:
    label: ホスト PID
    enable: "はい: ホストの PID 名前空間を使用します"
    disable: "いいえ"
  privileged:
    label: 特権モード
    enable: "はい: 特権付きコンテナを実行します"
    disable: "いいえ"
  readOnlyRootFilesystem:
    label: 読み取り専用ルートファイルシステム
    enable: "はい：読み取り専用のルートファイルシステムを使用する必要があります"
    disable: "いいえ"
hostSettings:
  header: ホスト登録 URL
  subtext: '{appName} API に接続するための URL は何にしますか?'
  hostUrl:
    local: "サイトのアドレス:"
    new:
      labelText: "それ以外:"
      placeholder: "例: http://example.com:8080"
  helpText:
    static1: "<code>/v1</code> などのパスは含めないで下さい。もし、"
    static2: "を {appName} の前段で行う場合は <code>https://</code> を指定することに注意してください。"
    isRancher: '<a href="{docsBase}/installing-rancher/installing-server/basic-ssl-config/" target="_blank">SSL 終端処理</a>'
    sslTerm: SSL 終端処理
  notPublic:
    alert: |
      作成された全てのホストは<code>{activeValue}</code>にアクセスできますか?<br/>プライベート IP や ローカルネットワークに見受けられます。
  badTld:
    alert: |
      トップレベルドメインである <code>.local</code> はRFC6742 でマルチキャスト DNS 向けに予約されています。そのため登録 URL に利用することは推奨されず、利用した場合 DNS 上の問題が発生する可能性があります。他のホスト名または IP を指定してください。
hostPod:
  supportState:
    unsupported: サポートされていない Docker バージョン
    untested: 未テストの Docker バージョン
  groupedInstances:
    namespace: '名前空間:'
    stack: 'スタック:'
    standalone: 独立型コンテナ
identityBlock:
  loading: 読込中...
inputAnswers:
  yaml: YAML として編集
  config: 設定オプション
  editAsForm: フォームで指定
  yamlProtip: PREVIEWセクションにデフォルト設定があります
  unknownType: "有効でないパラメータータイプ:"
  noConfig: このテンプレートには設定オプションがありません
  protip: "ペーストと読み取り処理では、列挙されたパラメーターが yml/yaml 形式である必要があります"
inputIdentity:
  placeholder:
    github: GitHub ユーザーまたは組織名を追加
    generic: ユーザーまたはグループ名を追加
  dropdownLabel:
    teams: あなたのチームと組織
    groups: あなたのグループ
inputPassword:
  buttonText: 生成
inputTextFile:
  tooltip: ファイルから読み込む
uploadFile:
  label: ファイルから読み込む
podsSection:
  title: ポッド
  detail: このワークロード内のポッド
labelsSection:
  kind: 種類
  title: ラベル
  detail: ノードスケジューリングルールやその他の詳細オプション設定の一部で利用されるキー/値 データ
  status: |
    {count, plural,
    =0 {ラベルはありません}
    =1 {# ラベル}
    other {# ラベル}
    }
  key: キー
  value: 値
  noData: ラベルはありません
  noMatch: 検索条件に一致するラベルがありません
loginShibboleth:
  buttonText: シボレスでログイン
loginGithub:
  buttonText: GitHub でログイン
loginAzure:
  buttonText: Azure ADでログイン
loginUserPass:
  local: ローカルユーザーを使用
  provider: "{kind}"
  userLabel: ユーザー名
  remember: パスワードを保存
  userPlaceholder: '例: jsmith'
  genericLoginLabel: ログイン
  loginLabel: '{provider} でログイン'
  loggingInLabel: ログイン中...
  passwordLabel: パスワード
machineTemplatesPage:
  title: ノードを追加
  new:
    helpText: 新しいノードを起動するか、すでにSSH経由でDockerを実行しているノードをインポートしてください。
    btn: 設定
  custom: Docker を既に実行している既存のノードをカスタムして追加
  templateBox:
    button: 選択
    labels:
      region: リージョン
      zone: ゾーン
newCertificate:
  title:
    new: 証明書を追加
    edit: '証明書を編集: {name}'
    view: '証明書: {name}'
  key:
    label: プライベートキー
    required: プライベートキーは必須です
    invalidFormat: 無効なプライベートキーです
    placeholder: "-----BEGIN RSA PRIVATE KEY----- から始まるプライベートキーを張り付けてください"
  cert:
    label: 証明書
    required: 証明書は必須です
    invalidFormat: 無効な証明書です
    placeholder: "-----BEGIN CERTIFICATE----- から始まる証明書と任意の必要な証明書チェーンを貼り付けてください"
    protip: 必要な証明書チェーンを含めてください。
  certChain:
    label: 証明書チェーン
    placeholder: "-----BEGIN CERTIFICATE----- から始まる追加の証明書チェーンを張り付けてください（オプション）"
  metaXML:
    label: メタデータ XML
    placeholder: "IDPメタデータXMLを貼り付けてください"
  errors:
    encrypted: プライベートキーはパスワードによって保護されていません
    key:
      required: プライベートキーは必須です
      invalidFormat: 無効なプライベートキーです。RSA キーか確認してください。
    cert:
      required: 証明書は必須です
      invalidFormat: 無効な証明書です
modalAboutComponent:
  component: コンポーネント
  version: バージョン
  cattle: Cattle
  cli: CLI
  ui: User Interface
  helm: Helm
  machine: Machine
modalAddPayment:
  header: 新しい支払い方法を追加
  save: 保存
  errors:
    cc: 無効なクレジットカード番号です
    exp: 無効な有効期限です
    cvc: 無効な CVC 番号です
    street: 番地情報が必要です
    city: 市区町村情報が必要です
    state: 州情報が必要です
    zip: 郵便番号が必要です
  form:
    currency:
      label: 支払い通貨を選んでください
    cc:
      label: クレジットカード番号
      placeholder: '•••• •••• •••• ••••'
    default:
      label: デフォルトカード
    name:
      label: クレジットカード記載名
      placeholder: 'Taro Yamada'
    exp:
      label: 有効期限
      placeholder: '••/••'
    cvc:
      label: CVC
      placeholder: '•••'
    address:
      addressLine1:
        label: 番地
        placeholder: 742 Evergreen Terrace
      addressLine2:
        label: ビル・建物名
        placeholder: Apt. 123
      city:
        label: 市区町村
        placeholder: Springfield
      state:
        label: 州
        placeholder: または
      zip:
        label: 郵便番号
        placeholder: '99999'
      country:
        label: 国名
        placeholder: アメリカ合衆国
  currencies:
    yuan: "中国元 (¥)"
    euro: "ユーロ (€)"
    dollar: "US ドル($)"
modalContainerStop:
  header: "本当に停止してもよろしいですか?"
  helpText: "タイムアウト時間内に停止しない場合、コンテナは強制終了されます"
  protip: "ProTip: この確認画面を飛ばす場合は停止ボタンのクリック時に {key} キーを長押ししてください。"
  label: タイムアウト
  button: 停止
modalConfirmDeactivate:
  header: 本当にこの処理を行ってよろしいですか?
  protip: "ProTip: この確認画面を飛ばす場合は {isServiceButton} クリック時に {key} キーを長押ししてください。"
  cancel: キャンセル
  buttons:
    project:
      message: 環境を非アクティブ化
      button: 非アクティブ化
    environment:
      message: 次のサービスを停止
      button: サービスを停止
    default:
      message: 非アクティブ化
      button: 非アクティブ化
modalConfirmRemovePayment:
  header: '支払いの削除の確認'
  title: '本当に削除してもよろしいですか?'
  card: 'カードは {card} で失効します'
modalEditDriver:
  url:
    label: ダウンロード URL
    help: 64-bit Linux のマシンドライバーをダウンロードする URL 。
  uiUrl:
    label: カスタム UI URL
    help: "オプション: このドライバー向けにカスタマイズされたノード追加画面を読み込むための URL です。"
    link: 詳細は <a href="https://github.com/rancher/ui-driver-skel" target="_blank">ui-driver-skel</a> を参照してください。
  checksum:
    label: チェックサム
    help: "オプション: 期待されたチェックサムかどうかダウンロードされたマシンドライバーの整合性を確認します。"
  whitelist:
    label: ホワイトリスト ドメイン
    addActionLabel: ドメインを追加
    noData: ドメインはありません
modalEditSetting:
  title: 拡張設定を編集
  name:
    label: 名前
  value:
    label: 値
    prompt: 値を選択してください...
  reset:
    label: デフォルトにリセット
modalEditPassword:
  firstLogin:
    title: '{appName} へようこそ'
    help: 最初のステップはデフォルトの <code>admin</code> ユーザーに対し強力なパスワードを設定することです
    actionButton: 続ける
  edit:
    title: パスワードを変更
    help: 新しいパスワードの変更方法を選択してください
  current: 現在のパスワード
  new: 新しいパスワード
  confirm: 新しいパスワード(確認用)
  mismatch: パスワードが一致しません
  actionButton: 変更
  mode:
    generate: 'ランダムに生成されたパスワードを使う:'
    manual: '手動でパスワードを設定する:'
modalFeedback:
  header: '{appName} へようこそ!'
  subtitle: "開始する前にあなたのことについて少し教えてください..."
  send: はじめに
modalHostEvacuate:
  header: "本当に退避してもよろしいですか?"
  helpText: "この操作はホストを非アクティブ化しインフラストラクチャ コンテナ以外の全ての起動中コンテナを削除します。"
  protip: "この確認画面を飛ばす場合は退避ボタンのクリック時に {key} キーを長押ししてください。"
  button: 退避
modalImport:
  title: YAML をインポート
  mode:
    label: インポートモード
    cluster: "クラスター: リソースをクラスターに直接インポート"
    project: "プロジェクト: リソースをプロジェクトにインポート"
    namespace: "名前空間: リソースを特定の名前空間にインポート"
  detail:
    cluster1: ネームスペースリソースは必要に応じて作成されますが、このプロジェクトに自動的には追加されません
    cluster3: このモードでは、ネームスペースのないリソースもサポートします。例 RoleTemplate
modalProcessError:
  header: 例外情報
  cause: "理由:"
  none: N/A
  stackTrace: "スタックトレース:"
  close: 閉じる
modalDrainNode:
  gracePeriod:
    placeholder: '例: 60'
  timeout:
    placeholder: '例: 60'
modalRollbackService:
  title: '"{instanceName}" をロールバック'
  titleWithSidekicks: '"{instanceName}" と {count, plural, =1 {# サイドカー} other {# サイドカー}} をロールバック'
  action: ロールバック
  current:
    label: 現在のリビジョン
  revisionId:
    label: リビジョンへのロールバック
    prompt: リビジョンを選択してください...
  difference:
    label: 差分
modalRollbackApp:
  title: '"{appName}" をロールバック'
  action: ロールバック
  current:
    label: 現在のリビジョン
  revision:
    label: ロールバックするリビジョン
    prompt: リボジョンを選択してください...
  difference:
    label: 差分
modalShell:
  title: "シェル: "
modalShortcuts:
  title:
    rancher: "ワープゾーンへようこそ!"
    pl: キーボードショートカット
  global: グローバル
  cluster: クラスター
  project: プロジェクト
  other: その他の項目
  kubectl: Kubectl シェル
  viewGroup: ビューのグループ化の切り替え
  search: 検索フィールドにフォーカスする
  shortcuts: 現在地
modalYaml:
  title:
    new: '{type} YAML をインポート'
    edit: 'YAML を編集: {name}'
    view: 'YAML を表示: {name}'
modalWelcome:
  header: '{appName} へようこそ!'
  closeModal: 完了!
namespaceGroup:
  label: "名前空間: {name}"
  none: ポッド
  project: "プロジェクト内にありません"
nodeGroup:
  label: "ノード: {name}"
newIngress:
  header:
    add: イングレスを追加
    edit: イングレスを編集
  error:
    noRules: "１つ以上のルールが必要です。"
newBalancer:
  header:
    add: ロードバランサーを追加
    edit: ロードバランサーを編集
    upgrade: ロードバランサーをアップグレード
  error:
    noRules: "1つ以上のリスニングポートとターゲットルールが必要です。"
    noSourcePort: "各ルールにはソースポートが必要です"
    invalidSourcePort: "無効なソースポート: '{num}'"
    invalidTargetPort: "無効なターゲットポート: '{num}'"
    mixedPort: "ポート {num} はアクセスするプロトコルが競合する複数のルールを持っています"
    noTarget: "各ルールには対象が必要です"
    noTargetPort: "各ルールにはターゲットポートが必要です"
    needsCertificate: "SSL/TLS ポートルールであるため証明書が必要です"
    stackName: "新しいスタックには名前が必要です"
newCatalog:
  answers:
    label: アンサー
    addAction: アンサーを追加
  catalog: "カタログ:"
  category: "カテゴリー:"
  config: 設定オプション
  helm:
    label: 設定オプション
    protip: Helm テンプレートではカンマ区切りの文字列リストが許容されます
  kind: "カタログ種別:"
  license: "ライセンス:"
  maintainedBy: コミュニティメンバーによるメンテナンス
  maintainer: "メンテナー:"
  newNamespace: 新しい名前空間
  customizeNamespace: "このアプリケーションは <code>{namespaceId}</code> 名前空間内で起動します"
  newAppDetail: アプリケーションバージョンと名前空間を選択してください
  appInfo: 詳細な説明
  appInfoDetail: アプリケーション情報とユーザーガイド
  noConfig: このテンプレートには設定オプションがありません
  official: 公式に認証済み
  preview: プレビュー
  templateFiles: テンプレートファイル
  seeMore: より詳細な情報...
  saveConfigure: 設定
  saveNew: 起動
  saveUpgrade: アップグレード
  selectVersionAdd: デプロイするテンプレートのバージョンを選択してください
  selectVersionConfigure: 設定するテンプレートのバージョンを選択してください
  selectVersionUpgrade: アップグレードするテンプレートのバージョンを選択してください
  startService: 作成後にサービスを起動
  support: "サポート:"
  templateVersion: テンプレートバージョン
  titleAdd: "{name} アプリケーションを追加"
  titleConfigure: "{name} アプリケーションを設定"
  titleUpgrade: "{name} アプリケーションをアップグレード"
  txt: answers.txt
  unknownType: "有効でないパラメータータイプ:"
  upgrade: "アップグレード:"
  url: "プロジェクト URL:"
  version:
    prompt: バージョンを選択してください...
    default: 'デフォルトのバージョン (現在: {version})'
newContainer:
  add:
    container: ポッドをデプロイ
    service: ワークロードをデプロイ
    globalService: グローバルワークロードをデプロイ
    sidekick: 'サイドカーをデプロイ'
    sidekickName: '"{name}" のサイドカーをデプロイ'
  saveNew: 起動
  name:
    placeholder: '例: myapp'
  description:
    placeholder: '例: マイアプリケーション'
  environment:
    label: 環境変数
    from: 他のリソースからの投入値
    detail: シークレットなどの他のリソースから投入する値を含めコンテナから参照可能な環境変数を設定します
    addAction: 環境変数を追加
    addFrom: ソースを追加
    keyLabel: 変数
    keyPlaceholder: '例: FOO'
    valueLabel: 値
    valuePlaceholder: '例: bar'
  sidekick:
    primary: 基本サービス
    sidekick: サイドカー
  errors:
    noSidekick: サイドカーを追加したいワークロードを選択してください
    duplicateName: '"{service}" 内には "{name}" という名前のサイドカーが既に存在しています'
newPassword:
  placeholder: 新しいパスワード
  password: 新しいパスワード
  confirmPassword: 新しいパスワード(確認用)
  passwordNoMatch: パスワードが一致しません
newSecret:
  title:
    new: シークレットを追加
    edit: 'シークレットを編集: {name}'
    view: 'シークレット: {name}'
  name:
    placeholder: '例: api-key'
  description:
    placeholder: e.g. S3 key pair
  values:
    label: シークレットの値
  addActionLabel: シークレットの値を追加
nodeDriver:
  addTemplate: ノードテンプレートを追加
  editTemplate: "ノードテンプレートを編集: {name}"
  editWarning: 編集されたノードテンプレートはノードプールによって作成された新しいノードにのみ影響します。既存のノードは自動的に更新または置換されません。<br>プールからノードを削除した場合はテンプレート内の新しい設定を仕様して新しいノードが作成されます。
  displayName:
    aliyunecs: Aliyun ECS
    amazonec2: Amazon EC2
    azure: Azure
    digitalocean: DigitalOcean
    exoscale: Exoscale
    openstack: OpenStack
    otc: Open Telekom Cloud
    packet: Packet
    rackspace: RackSpace
    softlayer: SoftLayer
    vmwarevsphere: vSphere
    zstack: ZStack
  driverOptions: "{driver} オプション"
  templateOptions: "{appName} テンプレート"
  amazoneks:
    access:
      next: "次へ: サービスロールの選択"
      loading: Amazonからサービスロールをロード中...
    role:
      label: サービスロール
      noneSelected: "Rancherがロールを作成しました"
      help: "サービスロールを指定しない場合、Rancher により作成されます"
      radio:
        default: "標準: Rancherによるサービスロールの作成"
        custom: "カスタム: 既存のサービスロールから選択"
      next: "次へ: VPCとサブネットの選択"
      loading: "AmazonからVPCをロード中..."
    vpc:
      title: VPC/サブネット
      detail: EKSインスタンスを起動する際に利用するVPCを選択して下さい
      next: "次へ：サブネットの選択"
      loading: "Amazonからサブネットをロード中..."
      nextRancherDefault: "次へ: インスタンスオプションの選択"
      loadingRancherDefault: "インスタンスオプションを読み込んでいます..."
      noneSelected: "Rancher によりVPCとサブネットが作成されました"
      radio:
        default: "標準: RancherによるVPCとSubnetの作成"
        custom: "カスタム: 既存のVPCとSubnetから選択"
    subnet:
      title: サブネット
      next: "次へ：セキュリティグループの選択"
      loading: "Amazonからセキュリティグループをロード中..."
    associateWorkerNodePublicIp:
      radio:
        default: 'true'
    securityGroup:
      title: セキュリティグループ
      detail: EKSインスタンスに適用するセキュリティグループを選択してください
      choose: 既存のグループを選択
      defaultExisting: "通常: 既存の <code>{groupName}</code> グループを利用"
      next: "次へ: インスタンスオプションの設定"
      loading: インスタンスオプションを読み込んでいます...
  amazonec2:
    access:
      title: 1. アカウントアクセス
      detail: EC2 インスタンスを起動する際に利用するリージョンと API キーを選択してください
      next: "次へ: 認証とネットワークの選択"
      loading: EC2 からアベイラビリティゾーンと VPC 情報を読み込んでいます...
      help: "AWS のキーペアを貼り付けてください。新しいインスタンス作成にこのキーを利用します"
    zone:
      title: 2. ゾーンとネットワーク
      detail: インスタンスに対するアベイラビリティゾーンと VPC/サブネット を選択してください
      next: "次へ: セキュリティグループの選択"
      loading: EC2 からセキュリテイぃグループ情報を読み込んでいます...
    accessKey:
      label: アクセスキー
      placeholder: あなたの AWS アクセスキー
    secretKey:
      label: 秘密キー
      placeholder: あなたの AWS 秘密キー
      provided: 入力済み
    region:
      label: リージョン
    availabilityZone: アベイラビリティゾーン
    subnet: VPC/サブネット
    securityGroup:
      title: 3. セキュリティグループ
      detail: インスタンスに適用するセキュリティグループを選択してください
      choose: 既存のグループを選択
      defaultExisting: "通常: 既存の <code>{groupName}</code> グループを利用"
      defaultCreate: "通常: <code>{groupName}</code> グループを自動的に作成"
      next: "次へ: インスタンスオプションの設定"
      loading: インスタンスオプションを読み込んでいます...
    tags:
      addActionLabel: AWS タグを追加
      valueLabel: タグ
      placeholder: '例: dev'
    instance:
      title: 4. インスタンス
      detail: 作成される EC2 インスタンスをカスタマイズします
    portHelp:
      link: 詳細を見る
      text: 公開されるポート番号について
    needs:
      label: "{appName} が正常に機能するためにはセキュリティグループで以下のトラフィックを許可する必要があります:"
      item1: '{appName} サーバーから <code>TCP 22</code> 版ポート<span class="text-muted">(Docker を SSH 経由でインストール,設定するため)</span>"'
      item2: 他のホストへ、または他のホストからの <code>UDP 500</code> 番ポートと <code>4500</code> 番ポート<span class="text-muted">(IPsec ネットワークのため)</span></li>
      item3: これらのルールは自動的に追加 <b>されません</b>
    instanceType:
      label: インスタンスタイプ
    rootSize:
      label: ルートディスクサイズ
      unit: GB
    ami:
      label: AMI
      placeholder: Ubuntu AMI
      rancherList: RancherOS AMI リスト
    sshUser:
      label: SSH ユーザー
      placeholder: '例: ubuntu'
    iam:
      label: IAM プロファイル
      placeholder: my-k8s-profile
    privateIp:
      label: プライベート IP
    onlyPrivate:
      label: プライベート IP アドレスのみ使用
    requestSpotInstance:
      label: スポットインスタンス
      enable: スポットインスタンスをリクエスト
    spotPrice:
      label: スポット価格
      unit: '$'
  digitalocean:
    droplet:
      title: ドロップレットオプション
      detail: このテンプレートにより作成されたドロップレットのオプションを設定してください
    sizeLabel: |
      {highMem, select, true {高メモリ: } other {}}{memoryGb} GB RAM, {disk} GB ディスク, {vcpus, plural,
      =1 {# vCPU}
      other {# vCPUs}
      }
    authAccountButton: '次へ: ドロップレットの設定'
    accessToken:
      label: アクセストークン
      placeholder: あなたの DigitalOcean API アクセストークン
      help: |
        DigitalOcean <a href="https://cloud.digitalocean.com/settings/api/tokens" target="_blank" rel="nofollow noreferrer noopener">Applications & API</a> 画面から
        パーソナルアクセストークンを取得してください
    image:
      label: イメージ
    sshUser:
      label: SSH ユーザー
      placeholder: '例: root'
    size:
      label: ドロップレット サイズ
    region:
      label: リージョン
    optionsSection: オプション
    ipv6:
      label: IPv6 を有効化
    privateNetworking:
      label: プライベートネットワークを有効化
    monitoring:
      label: モニタリングを有効化
    tags:
      addActionLabel: ドロップレットタグを追加
      valueLabel: タグ
      placeholder: '例: dev'
  exoscale:
    accountSection: アカウントアクセス
    apiKey:
      label: API キー
      placeholder: あたたの Exoscale API キー
    secretKey:
      label: 秘密キー
      placeholder: あなたの Exoscale 秘密キー
      provided: 入力済み
    accountHelp: あなたの Exoscale キーペアをここにペーストしてください。キーペアは新しいインスタンスの作成に利用されます。
    loginAction: "次へ: 認証とセキュリティグループの選択"
    loadingSecurity: Exoscale からセキュリティグループ情報を読み込んでいます...
    securityGroupSection: セキュリティグループ
    securityGroup:
      label: セキュリティグループ
      defaultExisting: "標準: 既存の <code>{groupName}</code> グループを利用"
      defaultCreate: "標準: 自動的に <code>{groupName}</code> グループを作成"
      custom: "カスタム: 既存のグループを選択"
      updating: セキュリティグループを更新中...
      creating: セキュリティグループを作成中...
    loadingZone: Exoscale からゾーン情報を読み込んでいます...
    zoneSection: ゾーン
    selectZoneAction: "次へ: セキュリティグループの選択"
    zone:
      label: ゾーン
    portHelp:
      link: 詳細を見る
      text: 公開されるポート番号について
    needs:
      label: "{appName} が正常に機能するためにはセキュリティグループで以下のトラフィックを許可する必要があります:"
      item1: '{appName} サーバーから <code>TCP 22</code> 版ポート<span class="text-muted">(Docker を SSH 経由でインストール,設定するため)</span>"'
      item2: 他のホストへ、または他のホストからの <code>UDP 500</code> 番ポートと <code>4500</code> 番ポート<span class="text-muted">(IPsec ネットワークのため)</span></li>
      item3: これらのルールは自動的に追加 <b>されません</b>
    selectSecurityGroupAction: "次へ: インスタンスオプションの設定"
    loadingInstance: 利用可能なインスタンス設定を取得中...
    instanceSection: インスタンス
    instanceProfile:
      label: インスタンスプロファイル
    diskSize:
      label: ルートディスクサイズ
    sshUser:
      label: SSH ユーザー
    template:
      label: テンプレート
  packet:
    accountSection: アカウントアクセス
    projectId:
      placeholder: あなたの Packet プロジェクト ID
    apiKey:
      label: API キー
      placeholder: あなたの Packet API キー
    apiKeyHelp: 'Packet <a href="https://app.packet.net/portal#/api-keys" target="_blank">API Keys</a> 画面より取得してください'
    instanceSection: インスタンス
    instanceOptionsSection: インスタンスオプション
    loginAction: "次へ: 認証とインスタンスの選択"
    authentication: 認証
    location: ロケーション
    planDetails:
      label: インスタンス詳細
      cpu: CPUs
      memory: メモリ
      drives: ドライブ
      network: NICs
    image:
      label: イメージ
    size:
      label: サイズ
    regionSection: リージョン
    region:
      label: リージョン
  rackspace:
    account:
      title: 1. アカウントアクセス
      detail: ユーザー名とAPIキーを使用してRackspaceインスタンスが起動されます
    username:
      label: ユーザー名
      placeholder: あなたの RackSpace ユーザー名
    apiKey:
      label: API キー
      placeholder: あなたの RackSpace API キー
    accountHelp: RackSpace コントロールパネルのアカウント設定画面から取得してください
    region:
      title: 2. リージョンとフレーバー
      detail: Rackspace インスタンスを起動する際に利用するリージョンとフレーバーを選択してください.
      label: リージョン
    flavor:
      label: フレーバー
  vmwarevsphere:
    access:
      title: 1. アカウントアクセス
      detail: vCenter や ESXi サーバーのアクセス情報を設定します
      help: "ノート: 試用版の ESXi ライセンスでは API アクセスがサポートされません。商用版ライセンスが適用されたサーバーのみサポートされます。"
    instance:
      title: 2. インスタンスオプション
      detail: 仮想マシンの OS とサイズを選択してください
    scheduling:
      title: 3. スケジューリング
      detail: 仮想マシンが配置されるホストを選択してください
    vcenter:
      label: vCenter または ESXi サーバー
      placeholder: vCenter または ESXi ホスト名/IP
    vcenterPort:
      label: ポート番号
    username:
      label: ユーザー名
    password:
      label: パスワード
    instanceSection: インスタンス
    instanceOptionsSection: インスタンスオプション
    cpuCount:
      label: CPUs
      unit: '{cores, plural, =1 {コア} other {コア}}'
    memorySize:
      label: メモリ
      unit: MB
    diskSize:
      label: ディスク
      unit: MB
    boot2dockerUrl:
      label: OS ISO URL
      placeholder: "デフォルト: 最新の boot2docker イメージ"
    schedulingSection: スケジューリング
    dataCenter:
      label: データセンター
      placeholder: "例: datacenter_name"
      help: "VM を作成するデータセンターです(スタンドアローンの ESXi の場合は空白にしてください)"
    pool:
      label: リソースプール
      placeholder: "例: /dc_name/host/host_name/Resources/pool_name"
      help: "VM を作成するリソースプールです(スタンドアローンの ESXi の場合は空白にしてください)"
    host:
      label: ホスト
      placeholder: "例: cluster_name/host_name"
      help: "VM を作成する特定ホストです(スタンドアローンの ESXi もしくは DRS が有効なクラスターの場合は空白にしてください)"
    network:
      label: ネットワーク
      placeholder: "例: VM Network"
      help: "VM にアタッチするネットワークです"
    dataStore:
      label: データストア
      placeholder: "例: datastore_cluster_name/datastore_name"
      help: "VM ディスクを配置するデータストアです"
    cloudinit:
      label: Cloud Init
      placeholder: "例: http://my_host/cloud-config.yml"
    folder:
      label: フォルダ
      placeholder: "例 /folder"
    cfgparam:
      key:
        placeholder: "例: guestinfo.hostname"
      value:
        placeholder: "例 myrancherhost"
      addActionLabel: パラメーターを追加
  azure:
    placement:
      title: 配置
      detail: このテンプレートにより作成されたインスタンスの配置先を選択してください
    access:
      title: アカウントアクセス
      detail: Azure インスタンスを起動するのに API キーが利用されます
    network:
      title: ネットワーク
      detail: このテンプレートにより作成されたインスタンスが接続するネットワークを設定してください
    instance:
      title: インスタンス
      detail: 作成された Azure インスタンスをカスタマイズします
    subscriptionId:
      label: サブスクリプション ID
      placeholder: あなたの Azure サブスクリプション ID
    subscriptionCert:
      label: サブスクリプション証明書
      placeholder: あなたの Azure サブスクリプション証明書
    image:
      label: イメージ
      placeholder: 'canonical:UbuntuServer:16.04.0-LTS:latest'
    size:
      label: サイズ
    dockerPort:
      label: Docker ポート
      placeholder: '2376'
    publishSettingsFile:
      label: 公開設定
      placeholder: あなたの公開設定ファイル
    environment:
      label: 環境
      placeholder: 'AzurePublicCloud'
    resourceGroup:
      label: リソースグループ
      placeholder: 'docker-machine'
    sshUser:
      label: SSH ユーザー
      placeholder: usr1
    storageType:
      label: ストレージタイプ
    vnet:
      label: VNet
      placeholder: '[resourcegroup:]name'
    subnet:
      label: サブネット
      placeholder: example-sub-name
    subnetPrefix:
      label: サブネットプリフィックス
      placeholder: 128.42.0.0/21
    availabilitySet:
      label: 可用性セット
      placeholder: 可用性セット名
    openPort:
      label: 公開ポート
      placeholder: 'カンマ区切りの番号, 例: 80,443'
    privateIpAddress:
      label: プライベート IP
      placeholder: 127.0.0.1
    usePrivateIp:
      label: プライベート IP を使用して接続
    staticPublicIp:
      label: パブリック IP
    noPublicIp:
      label: パブリック IP はありません
    clientId:
      label: クライアント ID
      placeholder: あなたのクライアント ID
    clientSecret:
      label: クライアントシークレット
      placeholder: あなたのクライアントシークレット
    region:
      label: リージョン
  aliyunecs:
    accountSection:
      label: 1. アカウントアクセス
      detail: Aliyun ECS インスタンスを起動するのに API キーが利用されます
      next: "次へ: 認証とネットワークオプション"
      loading: Aliyun ECSからリージョンをロード中...
    accessKey:
      label: アクセスキー*
      placeholder: あなたの Aliyu アカウントアクセスキー
    accessKeySecret:
      label: アクセスキーシークレット*
      placeholder: あなたのキーのシークレット
      provided: 取得済み
    apiEndpoint:
      label: API エンドポイント
      placeholder: プライベート Aliyun API サーバーのエンドポイント
    instanceOptionsSection:
      label: インスタンス
      detail: 作成された Aliyun インスタンスをカスタマイズします
    instanceDescription:
      label: インスタンス詳細
      placeholder: インスタンス詳細
    instanceType:
      label: インスタンスタイプ
      placeholder: インスタンスタイプ
    systemImage:
      label: システムイメージ
      placeholder: システムイメージ
    internetMaxBandwidth:
      label: インターネット最大帯域幅
      placeholder: 1 から 100
    aliyunSLB:
      label: Aliyun SLB ID
      placeholder: Aliyun SLB ID
    storageSection:
      label: ストレージ
      detail: このテンプレートにより作成されたインスタンスが接続するストレージを設定してください
      next: "次へ: Aliyun ECSインスタンスの設定オプション"
      loading: Aliyun ECSからインスタンスタイプとイメージをロードしています...
    ioOptimized:
      label: インスタンス ストレージ I/O 最適化
      none: なし
    systemDiskCategory:
      label: システムディスクカテゴリ
    dataDiskCategory:
      label: データディスクカテゴリ
    dataDiskSize:
      label: データディスクサイズ
      placeholder: ディスクサイズ
    region:
      label: リージョン
      placeholder: リージョン
    zone:
      label: アベイラブルゾーン
      prompt: 利用可能なゾーンを選択して下さい...
    networkSection:
      label: ネットワーク
      detail: このテンプレートにより作成されたインスタンスが接続するネットワークを設定してください
      next: "次へ: ストレージ設定オプション"
      loading: Aliyun ECSからストレージタイプをロード中...
    routeCIDR:
      label: ルート CIDR
      placeholder: '例: 192.168.1.0/24'
    vpcId:
      label: Aliyun VPC ID
      prompt: VPNを選択...
    vswitchId:
      label: Aliyun 仮想スイッチ ID
      prompt: VSwitch を選択...
    privateIp:
      label: プライベート IP
      placeholder: プライベートネットワーク内のプライベート IP
    privateAddressOnly:
      label: プライベートアドレスのみ
    securitySection:
      label: セキュリティ
      detail: インスタンスに適用するセキュリティグループを選択してください
    securityGroup:
      label: セキュリティグループ
      placeholder: セキュリティグループ
      prompt: セキュリティグループを選択...
      defaultCreate: "<code>{groupName}</code> グループを自動的に作成"
    sshPassword:
      label: SSH パスワード
      placeholder: インスタンスの SSH パスワードを設定してください。空の場合自動的に設定されます。
      provided: 取得済み
    tags:
      addActionLabel: インスタンスタグを追加
      valueLabel: タグ
      placeholder: '例: dev'
    errors:
      vpcIdRequired: VPC は必須です。
      vswitchIdRequired: VSwitchが必要です
      accessKeyRequired: アクセスキーは必須です
      accessSecretRequired: シークレットキーは必須です
      sshPasswordLengthNotValid: SSHパスワードの長さは8〜30でなければなりません。
      sshPasswordInvalidCharacter: SSHパスワードに無効な文字が含まれています。
      sshPasswordFormatError: "SSHパスワードには、次の4種類の文字のうち3つ以上の文字を含める必要があります: 大文字、小文字、数字、特殊文字"
      nameNotValidForApp: この名前は、{appName} のホスト名規約により無効です
  zstack:
    access:
      title: 1. アカウントアクセス
      detail: ZStack インスタンスを起動するためのエンドポイントとアカウント名、アカウントパスワードを選択してください
      next: "次へ: 認証とネットワークの選択"
      loading: ZStack からゾーン、クラスター、ネットワーク情報を読み込み中...
    endpoint:
      label: エンドポイント
      placeholder: '例: https://192.168.1.42:8443/'
    accountName:
      label: アカウント名
      placeholder: あなたのアカウント名
    accountPassword:
      label: アカウントパスワード
      placeholder: あなたのアカウントパスワード
      provided: 入力済み
    zone:
      title: 2. ゾーン、クラスター、ネットワークの設定
      detail: インスタンス用のゾーン、クラスター、ネットワークを選択してください
      next: "次へ: インスタンスオプションの設定"
      loading: ZStack からインスタンスオプションを読み込み中...
      label: ゾーン
    cluster:
      label: クラスター
    network:
      defaultCreate: "標準: 自動的に <code>{groupName}</code> ネットワークを作成"
      choose: 既存のネットワークを選択
      label: ネットワーク
    portHelp:
      link: 詳細を見る
      text: 公開されるポート番号について
    instance:
      title: 3. インスタンス
      detail: 作成される EC2 インスタンスをカスタマイズします
    instanceOffering:
      label: インスタンスタイプ
    systemDiskOffering:
      label: システムディスク
    imageName:
      label: イメージ名
    dataDiskOffering:
      label: データディスク
newConfigMap:
  title:
    new: コンフィグマップを追加
    edit: 'コンフィグマップを編集: {name}'
    view: 'コンフィグマップ: {name}'
  name:
    placeholder: '例: map'
  description:
    placeholder: '例: app'
  values:
    label: コンフィグマップ値
  addActionLabel: コンフィグマップ値を追加
projectGroup:
  label: "プロジェクト: {name}"
  none: 名前空間
  project: プロジェクト内にありません
  noNS: このプロジェクトには名前空間がありません
optionallyNamespaced:
  scope:
    label: スコープ
    project: このプロジェクトのすべての名前空間で使用可能
    namespace: 単一の名前空間で利用可能
orchestrationWelcome:
  simple:
    title: シンプル
  enhanced:
    title: Kubernetesによる強化
pageFooter:
  notARelease: (未リリース)
  help: 'ヘルプ & ドキュメント'
  issues: バグを報告
  forums: フォーラム
  slack: Slack
  download:
    link: CLI をダウンロード
    mac: macOS
    windows: Windows
    linux: Linux
  showSystem: システムコンテナを表示
pagination:
  catalog: |
    {pages, plural,
    =0 {カタログはありません}
    =1 {{count} {count, plural, =1 {カタログ} other {カタログ}}}
    other {{from} - {to} of {count} Catalogs}}
  certificate: |
    {pages, plural,
    =0 {証明書はありません}
    =1 {{count} {count, plural, =1 {証明書} other {証明書}}}
    other {{from} - {to} of {count} Certificates}}
  container: |
    {pages, plural,
    =0 {クラスターはありません}
    =1 {{count} {count, plural, =1 {クラスター} other {クラスター}}}
    other {{from} - {to} of {count} Clusters}}
  cluster: |
    {pages, plural,
    =0 {クラスターはありません}
    =1 {{count} {count, plural, =1 {クラスター} other {クラスター}}}
    other {{from} - {to} of {count} Clusters}}
  dnsRecord: |
    {pages, plural,
    =0 {DNS レコードはありません}
    =1 {{count} {count, plural, =1 {DNS レコード} other {DNS レコード}}}
    other {{from} - {to} 個の {count} DNS レコード}}
  driver: |
    {pages, plural,
    =0 {ドライバーはありません}
    =1 {{count} {count, plural, =1 {ドライバー} other {ドライバー}}}
    other {{from} - {to} of {count} Drivers}}
  driverOptions: |
    {pages, plural,
    =0 {オプションはありません}
    =1 {{count} {count, plural, =1 {ドライバーオプション} other {ドライバーオプション}}}
    other {{from} - {to} of {count} Driver Options}}
  entry: |
    {pages, plural,
    =0 {エントリーはありません}
    =1 {{count} {count, plural, =1 {エントリー} other {エントリー}}}
    other {{from} - {to} of {count} Entries}}
  event: |
    {pages, plural,
    =0 {イベントはありません}
    =1 {{count} {count, plural, =1 {イベント} other {イベント}}}
    other {{from} - {to} of {count} Events}}
  generic: |
    {pages, plural,
    =0 {項目はありません}
    =1 {{count} {count, plural, =1 {項目} other {項目}}}
    other {{from} - {to} of {count} Items}}
  image: |
    {pages, plural,
    =0 {イメージはありません}
    =1 {{count} {count, plural, =1 {イメージ} other {イメージ}}}
    other {{from} - {to} of {count} Images}}
  link: |
    {pages, plural,
    =0 {リンクはありません}
    =1 {{count} {count, plural, =1 {リンク} other {リンク}}}
    other {{from} - {to} of {count} Links}}
  loadBalancer: |
    {pages, plural,
    =0 {ロードバランサーはありません}
    =1 {{count} {count, plural, =1 {ロードバランサー} other {ロードバランサー}}}
    other {{from} - {to} of {count} Load Balancers}}
  ingress: |
    {pages, plural,
    =0 {イングレスはありません}
    =1 {{count} {count, plural, =1 {イングレス} other {イングレス}}}
    other {{from} - {to} of {count} Ingresses}}
  member: |
    {pages, plural,
    =0 {メンバーはいません}
    =1 {{count} {count, plural, =1 {メンバー} other {メンバー}}}
    other {{from} - {to} of {count} Members}}
  mount: |
    {pages, plural,
    =0 {マウントはありません}
    =1 {{count} {count, plural, =1 {マウント} other {マウント}}}
    other {{from} - {to} of {count} Mounts}}
  namespace: |
    {pages, plural,
    =0 {名前空間はありません}
    =1 {{count} {count, plural, =1 {名前空間} other {名前空間}}}
    other {{from} - {to} of {count} Namespaces}}
  node: |
    {pages, plural,
    =0 {ノードはありません}
    =1 {{count} {count, plural, =1 {ノード} other {ノード}}}
    other {{from} - {to} of {count} Nodes}}
  nodePool: |
    {pages, plural,
    =0 {ノードプールはありません}
    =1 {{count} {count, plural, =1 {ノードプール} other {ノードプール}}}
    other {{from} - {to} of {count} Node Pools}}
  nodeTemplate: |
    {pages, plural,
    =0 {ノードテンプレートはありません}
    =1 {{count} {count, plural, =1 {ノードテンプレート} other {ノードテンプレート}}}
    other {{from} - {to} of {count} Node NodeTemplates}}
  pod: |
    {pages, plural,
    =0 {ポッドはありません}
    =1 {{count} {count, plural, =1 {ポッド} other {ポッド}}}
    other {{from} - {to} of {count} Pods}}
  podHighlightSubset: "<b>{count} のうち {subset} </b> ポッド"
  podNoSubset: "{count} ポッドのうち 0 ポッド"
  podLabel: |
    {count, plural,
    =1 {ポッド}
    other {ポッド}
    }
  port: |
    {pages, plural,
    =0 {ポートはありません}
    =1 {{count} {count, plural, =1 {ポート} other {ポート}}}
    other {{from} - {to} of {count} Ports}}
  project: |
    {pages, plural,
    =0 {プロジェクトはありません}
    =1 {{count} {count, plural, =1 {プロジェクト} other {プロジェクト}}}
    other {{from} - {to} of {count} Projects}}
  rule: |
    {pages, plural,
    =0 {ルールはありません}
    =1 {{count} {count, plural, =1 {ルール} other {ルール}}}
    other {{from} - {to} of {count} Rules}}
  service: |
    {pages, plural,
    =0 {サービスはありません}
    =1 {{count} {count, plural, =1 {サービス} other {サービス}}}
    other {{from} - {to} of {count} Services}}
  storageClass: |
    {pages, plural,
    =0 {ストレージクラスはありません}
    =1 {{count} {count, plural, =1 {ストレージクラス} other {ストレージクラス}}}
    other {{from} - {to} of {count} Storage Classes}}
  volume: |
    {pages, plural,
    =0 {ボリュームはありません}
    =1 {{count} {count, plural, =1 {ボリューム} other {ボリューム}}}
    other {{from} - {to} of {count} Volumes}}
  workload: |
    {pages, plural,
    =0 {ワークロードはありません}
    =1 {{count} {count, plural, =1 {ワークロード} other {ワークロード}}}
    other {{from} - {to} of {count} Workloads}}
projectRow:
  none: 詳細情報はありません
  orchestration: オーケストレーション
publicEndpoints:
  endpoint: エンドポイント
  bindIpAddress: バインド IP
  publicPort: パブリックポート
  target: 対象
  privatePort: コンテナポート
  noData: 公開されているポートはありません
  noMatch: 検索条件に一致するポートはありません
physicalStats:
  title: 物理マシン属性
  detail: 物理マシンの属性情報です
registryRow:
  address: アドレス
  username: ユーザー名
  created: 作成日
reservationParameters:
  label: リソース制限
  memory:
    labelText: 'メモリ'
    placeholder: 'デフォルト: 全ホスト'
    unit: 'MB'
  milliCpu:
    labelText: CPU
    placeholder: 'デフォルト: 全ホスト'
    unit: 'mCPU'
saveCancel:
  saving: 保存中...
  saved: 完了!
  edit: 保存
  next: 次へ
  create: 作成
  cancel: キャンセル
schema:
  inputBoolean:
    y: "はい"
    n: "いいえ"
  inputCertificate:
    prompt: 証明書を選択してください...
  inputContainer:
    prompt: コンテナを選択してください...
  inputConfigMap:
    prompt: コンフィグマップを選択してください...
  inputEnum:
    option: オプションを選択してください...
  inputHost:
    label: ホストを選択してください...
  inputService:
    prompt: ワークロードを選択してください...
    custom: カスタム
  inputDnsRecord:
    prompt: サービスを選択してください...
  inputStorageClass:
    prompt: デフォルトクラスを使う...
  inputSecret:
    secret: シークレットを選択してください...
    certificate: 証明書を選択してください...
schedulingRuleRow:
  theHost: ホスト
  must: must
  should: should
  shouldNot: should not
  mustNot: must not
  haveA: have a
  of: of
  hostLabel: ホストラベル
  containerLabel: ラベル付きコンテナ
  serviceName: 名前付きサービス
  containerName: 名前付きコンテナ
serverUrl:
  header:
    label: Rancher サーバー URL
    detail: "どのような URL をこの {appName} サーバーに利用しますか? クラスター内の全てのノードはこの URL に通信可能である必要があります。"
  button:
    save: URL を保存する
siteAccess:
  header: サイトアクセス
  helpText: "誰がログインし {appName} を利用できるか設定してください"
  unrestricted: "全ての有効な {individuals} を許可"
  restricted: "クラスターのメンバーと認証済み {individuals}、{collection} を許可"
  required: "認証済み {individuals} と {collection} のみに制限"
  listHeader: "認証済み {individuals} と {collection}"
  dupe: "ユーザーアクセスは既に有効になっています"
  minimum: '少なくとも1つの承認済みエントリーを追加する必要があります'
  noIdentity: None
  users: ユーザー
  groups: グループ
  organizations: 組織
systemInfoSection:
  title: システム情報
  detail: システムとkubernetesの情報。
  key: キー
  value: 値
  noData: データがありません
  arch: アーキテクチャー
  dockerVersion: Dockerバージョン
  kernelVersion: カーネルバージョン
  kubeletVersion: Kubeletバージョン
  kubeProxyVersion: Kube Proky バージョン
  operatingSystem: オペレーティングシステムイメージ
  osType: オペレーティングシステム
  noMatch: 検索条件に一致するシステム情報がありません
tableCountSelect:
  header: ページ毎のテーブル行数
telemetryOpt:
  header: 統計情報
  subtext: |
    Rancher Labs では {appName} のインストール構成に関する匿名の情報を収集したいと思います<br/>。特定のリソース名、IP アドレス、その他識別情報などは収集されません<br/>。収集された情報はどのようにユーザーが Rancher を利用しているかを理解し、将来の開発における優先度を決めるために利用されます。
  learnMore:
    label: 詳細を見る
  label: 匿名の統計情報の収集を許可する
tooltipLink:
  list: リスト
  composeYaml: Compose YAML
tooltipWarning:
  notConfigured: アクセスコントロールは設定されていません
  dismiss: 表示しない
upgradeBtn:
  version:
    current: '現行'
  status:
    none: 'アップグレード: None'
    loading: 'アップグレードを確認中...'
    current: '最新'
    available: 'アップグレードが利用できます'
    inprogress: 'アップグレード中です'
    upgraded: 'アップグレード完了: アップグレードが終了しました'
    error: 'アップグレードのチェックに失敗しました'
    required: 'アップグレードが必要です'
jsonEditor:
  placeholder: "JSON形式で入力してください"
viewEditDescription:
  form:
    name:
      placeholder: '例: ラボ'
    description:
      placeholder: e.g. 開発者向けテスト用環境
volumesPage:
  title: ボリューム要求
  addActionLabel: ボリューム要求を追加
  noData: まだ永続ボリューム要求は定義されていません
  noMatch: 検索条件に一致する永続ボリューム要求はありません
  claimName:
    label: 要求名
  volume:
    label: 永続ボリューム
  storageClass:
    label: ストレージクラス
vmConsole:
  header: "コンソール:"
  protip: "ProTip: 新しいウィンドウで起動する場合はシェルアクセスを開く際に {key} を長押ししてください。"
  canvas: キャンバスがサポートされていません。
  footerActions:
    buttonSend: Ctrl-Alt-Delete を送る
    buttonCancel: 閉じる
volumeRow:
  mounts:
    readOnly: "(読み取り専用)"
waitOrchestration:
  count: '{count} のうち {sub}'
waitKubernetes:
  addHost: '1台のホストを追加しています'
  activateHost: 'ホストがアクティブになるのを待っています'
  createStack: 'Kubernetes のシステムスタックを作成中'
  startServices: 'サービスを起動中'
  waitApi: 'Kubernetes API を待っています'
searchableSelect:
  noMatch: 該当なし
  noOptions: 利用可能なオプションはありません。
containerChoices:
  hostGroup: "ホスト: {name}"
  hostGroupWithState: "ホスト: {name} ({state})"
  unknownHost: "ホスト: ???"
  containerOption: "{name}"
allWorkloads:
  namespace: "名前空間: {name}"
nav:
  srToggleDropdown: ドロップダウンを切り替え
  cluster:
    dashboard: クラスター
    members: メンバー
    nodes: ノード
    namespaces: 名前空間
    storage:
      tab: ストレージ
      classes: ストレージクラス
      volumes: 永続ボリューム
    projects: プロジェクト/名前空間
  containers:
    tab: ワークロード
    systemTab: システム
    ingresses: ロードバランサー
    containers: ワークロード
    dns: サービスディスカバリ
    volumes: ボリューム
    pipelines: パイプライン
    deploy: デプロイ
    addContainer: コンテナを追加
    addBalancer: バランサーを追加
    addIngress: イングレスを追加
    addDns: レコードを追加
    addVolume: ボリュームを追加
    importCompose: YAML をインポート
  group:
    none: フラットリスト
    node: ノードによるグループ化
    workload: ワークロードによるグループ化
    namespace: 名前空間によるグループ化
    namespaceWorkload: 名前空間/ワークロードによるグループ化
  hosts:
    tab: ノード
    addHost: ノードを追加
  catalog:
    all: 全て
    library: ライブラリ
    community: コミュニティ
  apps:
    launch: 起動
  infra:
    tab: リソース
    storagePage: ストレージ
    certificates: 証明書
    configMaps: コンフィグマップ
    registries: レジストリ
    secrets: シークレット
    members: メンバー
  admin:
    tab: グローバル
    accounts: ユーザー
    clusters: クラスター
    machines: ノード
    catalogs: カタログ
    security:
      tab: セキュリティ
      roles: ロール
      members: メンバー
      podSecurityPolicies: ポッドセキュリティポリシー
      authentication: 認証
    settings:
      tab: 設定
      auth: アクセスコントロール
      registration: ホスト登録
      advanced: 詳細
  user:
    label: "ユーザーメニュー: {username}"
    logout: ログアウト
  userPreferences:
    link: "アカウント設定"
  nodeTemplates:
    link: "ノードテンプレート"
  api:
    link: "API & キー"
  settings:
    tab: 設定
    advanced: 詳細
  tools:
    alerts: アラート
    logging: ログ
    notifiers: 通知
    pipeline: パイプライン
    tab: ツール
  project:
    none: グループ化されたプロジェクト/名前空間
    namespaces: 名前空間
action:
  activate: アクティブ化
  addContainer: ポッドをデプロイ
  addSidekick: サイドカーを追加
  clone: クローン
  console: コンソールを開く
  convertToService: サービスに変換
  deactivate: 非アクティブ化
  downloadYaml: YAML をダウンロード
  edit: 編集
  editConfig: 設定を編集
  editService: サービスを編集
  editYaml: YAML の参照/編集
  evacuate: 退避
  execute: シェルを実行
  exportConfig: 設定をエクスポート
  garbageCollect: クリーンアップ
  logs: ログを見る
  makeDefault: デフォルトに設定
  move: 移動
  mute: ミュート
  nodeConfig: キーをダウンロード
  pause: 一時停止
  pauseAll: 全て一時停止
  remove: 削除
  replay: 再実行
  resetDefault: デフォルトをリセット
  restart: 再起動
  resume: 再開
  retry: リトライ
  revert: デフォルトに戻す
  rollback: ロールバック
  setDefault: ログイン環境として設定する
  setting: 設定
  start: 開始
  startAll: すべて開始
  stop: 停止
  stopAll: すべて停止
  test: テスト
  unmute: ミュート解除
  upgrade: アップグレード
  upgradeOrEdit: アップグレード/編集
  viewConfig: 設定を見る
  viewGraph: グラフを見る
  viewInApi: API を見る
  viewInstance: インスタンスを見る
  viewYaml: YAMLを見る
validation:
  required: '"{key}" が必要です'
  arrayLength:
    exactly: '"{key}" には {count, plural, =1 {# 項目} other {# 項目}} を含める必要があります'
    between: '"{key}" には {min} から {max} {max, plural, =1 {個} other {個}}の項目を含める必要があります。'
    min: '"{key}" には少なくとも {count} {count,plural,=1 {個} other {個}}の項目を含める必要があります。'
    max: '"{key}" に含まれる項目は {count} {count,plural,=1 {個} other {個}}以下である必要があります。'
  stringLength:
    exactly: '"{key}" は  {count,plural,=1 {# 文字} other {# 文字}}である必要があります。'
    between: '"{key}" の文字数は {min} 文字から {max} {max,plural,=1 {文字} other {文字}}である必要があります。'
    min: '"{key}" には少なくとも {count} {count,plural,=1 {文字} other {文字}}を含める必要があります。'
    max: '"{key}" は {count} {count,plural,=1 {文字} other {文字}}以下である必要があります。'
  number:
    exactly: '"{key}" はちょうど {val} である必要があります。'
    between: '"{key}" は {min} から {max} の間である必要があります。'
    min: '"{key}" は少なくとも {val} である必要があります。'
    max: '"{key}" は {val} 以下である必要があります。'
  chars: '"{key}" には {count, plural,=1 {# 個} other {# 個}} の不正な文字が含まれています: {chars}'
  dns:
    doubleHyphen: 2つの連続したハイフンを含むことはできません。
    hostname:
      startDot: '"{key}" をドットで始めることはできません。'
      empty: '"{key}"は少なくとも1文字でなければなりません'
      tooLong: '"{key}" は {max} 文字を超えることはできません'
      startNumber: '"{key}" を数字で始めることはできません。'
      startHyphen: '"{key}" は文字または数字で始まる必要があります'
      endHyphen: '"{key}" は文字または数字で終わる必要があります'
      emptyLabel: '"{key}" は2つの連続したドットを持つことはできません'
      tooLongLabel: '"{key}" は {max} 文字を超えるセクションを持つことはできません'
    label:
      startNumber: '"{key}" を数字で始めることはできません。'
      startHyphen: '"{key}" は文字または数字で始まる必要があります'
      endHyphen: '"{key}" は文字または数字で終わる必要があります'
      emptyLabel: '"{key}" は空にできません'
      tooLongLabel: '"{key}" は {max} 文字を超えることはできません'
  k8s:
    identifier:
      startLetter: '"{key}" は文字または数字で始まる必要があります'
      endLetter: '"{key}" は文字または数字で終わる必要があります'
      emptyPrefix: '"{key}" は空の接頭辞を持つことはできません'
      tooLongPrefix: '"{key}" は {max} 文字を超える接頭辞を持つことはできません'
      emptyLabel: '"{key}" は空のキーを持つことはできません'
      tooLongKey: '"{key}" は {max} 文字を超えるキーを持つことはできません'
model:
  account:
    kind:
      registeredAgent: 登録済みエージェント
      agent: エージェント
      service: サービス
      user: ユーザー
      admin: 管理者
      project: 環境
  cluster:
    name: クラスター名
  identity:
    displayType:
      user: ユーザー
      team: チーム
      group: グループ
      org: 組織
      localUser: ローカルユーザー
      unknown: "{type}?"
  ingress:
    displayKind: L7 イングレス
  machine:
    role:
      worker: ワーカー
      etcd: etcd
      controlPlane: コントロール
  openldapconfig:
    server:
      label: ホスト名または IP アドレス
    serviceAccountUsername:
      label: サービスアカウント ユーザー名
    serviceAccountPassword:
      label: サービスアカウント パスワード
    domain:
      label: ユーザー検索ベース
      placeholder: "例: ou=Users,dc=mycompany,dc=com"
      help: "ベース配下の以下のユーザーのみ検索に利用されます"
  projectMember:
    role:
      member: メンバー
      owner: オーナー
      readonly: 読み取り専用
      restricted: 制限済み
  service:
    displayKind:
      generic: サービス
      loadBalancer: L4 バランサー
growl:
  webSocket:
    connecting:
      title: WebSocketへの接続中にエラーが発生しました
      warning: サーバーへのWebSocket接続を確立できません。サーバーがプロキシやSSL Terminationデバイスの背後にある場合、ブラウザはWebSocketに接続できません。サーバーがプロキシの背後にある場合は、プロキシがWebSocketをサポートしていることを確認してください。この問題が解決されるまで、ストリーミング東経、ログ、シェル/コンソール、リソースの状態の自動更新は動作しません。
      safariCertWarning: 考えられる別の原因は、たとえ警告をバイパスするために継続するよう回答したとしても、Safariが認識されない証明書を使用したWebSocket接続を許可しないことです。サーバーには、Safariが自動的に信頼する承認された機関によって署名された証明書が必要です。
      disconnectedWarning: "サーバーから切断されました。再接続を試みます..."
storageClass:
  aws-ebs:
    title: Amazon EBS ディスク
  azure-disk:
    title: Azure ディスク
  azure-file:
    title: Azure ファイル
  cinder:
    title: Openstack Cinder ボリューム
  gce-pd:
    title: Google 永続ディスク
  glusterfs:
    title: Gluster ボリューム
  local:
    title: ローカルノードのディスク
  longhorn:
    title: Longhorn
  portworx-volume:
    title: Portworx ボリューム
  quobyte:
    title: Quobyte ボリューム
  rbd:
    title: Ceph RBD
  scaleio:
    title: ScaleIO ボリューム
  storageos:
    title: StorageOS
  vsphere-volume:
    title: VMWare vSphere ボリューム
volumeSource:
  aws-ebs:
    title: Amazon EBS ディスク
  azure-disk:
    title: Azure ディスク
  azure-file:
    title: Azure ファイルシステム
  cephfs:
    title: Ceph ファイルシステム
  config-map:
    title: コンフィグマップボリューム
  cinder:
    title: Openstack Cinder ボリューム
  secret:
    title: シークレットボリューム
  empty-dir:
    title: 空ディレクトリボリューム
  fc:
    title: ファイバチャネル
  flex-volume:
    title: Flex Volume
  flex-volume-longhorn:
    title: Longhorn
  flocker:
    title: Flocker
  gce-pd:
    title: Google 永続ディスク
  glusterfs:
    title: Gluster ボリューム
  host-path:
    title: ローカルノードパス
    path:
      label: ノード上のパス
      placeholder: '例: /data'
    kind:
      label: ノード上のパス条件
      Any: "どれでも: ターゲットのパスをチェックしない"
      DirectoryOrCreate: ディレクトリ、存在しない場合は作成する
      FileOrCreate: ファイル、存在しない場合は作成する
      Directory: 既存のディレクトリ
      File: 既存のファイル
      Socket: 既存のソケット
      CharDevice: 既存のキャラクターデバイス
      BlockDevice: 既存のブロックデバイス
  iscsi:
    title: iSCSI ターゲット
  local:
    title: ローカルノードディスク
  nfs:
    title: NFS 共有
  photon:
    title: Photon ボリューム
  portworx:
    title: Portworx ボリューム
  quobyte:
    title: Quobyte ボリューム
  rbd:
    title: Ceph RBD
  scaleio:
    title: ScaleIO ボリューム
  storageos:
    title: StorageOS
  vsphere-volume:
    title: VMWare vSphere ボリューム
  customLogPath:
    mountPath:
      label: ログパス
      placeholder: '例: /var/www'
      helpText: コンテナ内のログパスです
    logFormat:
      label: ログ形式
      useCustomRegex: カスタムの Fluentd 正規表現を利用
      useExistingLogFormat: 既存のログ形式を利用
      helpText: <a href="http://fluentular.herokuapp.com/" target="_blank"こちら</a> から正規表現のテストができます
yamlPage:
  errors: yaml でエラーが起きました
